<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="130" skipped="4" tests="248" time="113.754" timestamp="2020-12-02T18:59:34.348330" hostname="a329c4a11ab0"><testcase classname="tests.test_pytest.PyTestTests" name="test_assert_true[kg-topology-CloudEosRR1]" time="0.003" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_authentication_counters_are_incrementing_on_[kg-topology-CloudEosRR1]" time="0.000"><skipped type="pytest.skip" message="No AAA setup on DUTs">/project/vane/bin/tests/aaa/test_aaa.py:51: No AAA setup on DUTs</skipped></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_aaa_session_logging_is_working_on_[kg-topology-CloudEosRR1]" time="0.251" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_commands_authorization_methods_set_on_[kg-topology-CloudEosRR1]" time="0.247" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_exec_authorization_methods_set_on_[kg-topology-CloudEosRR1]" time="0.246" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_default_login_authentication_methods_set_on_[kg-topology-CloudEosRR1]" time="0.248" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_login_authentication_methods_set_on_[kg-topology-CloudEosRR1]" time="0.256" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_dot1x_authentication_methods_set_on_[kg-topology-CloudEosRR1]" time="0.248" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_enable_authentication_methods_set_on_[kg-topology-CloudEosRR1]" time="0.252" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_system_accounting_methods_set_on_[kg-topology-CloudEosRR1]" time="0.246" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_exec_accounting_methods_set_on_[kg-topology-CloudEosRR1]" time="0.249" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_priviledge_accounting_methods_set_on_[kg-topology-CloudEosRR1]" time="0.271" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_dot1x_accounting_methods_set_on_[kg-topology-CloudEosRR1]" time="0.247" /><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_is_running_on_[kg-topology-CloudEosRR1]" time="0.336" /><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_port_is_correct_on_[kg-topology-CloudEosRR1]" time="0.265" /><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_is_enabled_on_[kg-topology-CloudEosRR1]" time="0.270" /><testcase classname="tests.api.test_api.APITests" name="test_if_management_http_api_server_is_running_on_[kg-topology-CloudEosRR1]" time="0.259" /><testcase classname="tests.api.test_api.APITests" name="test_if_management_local_http_api_server_is_running_on_[kg-topology-CloudEosRR1]" time="0.257" /><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_1_sec_cpu_utlization_on_[kg-topology-CloudEosRR1]" time="0.326" /><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_1_min_cpu_utlization_on_[kg-topology-CloudEosRR1]" time="0.332" /><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_5_min_cpu_utlization_on_[kg-topology-CloudEosRR1]" time="0.321" /><testcase classname="tests.daemon.test_daemon.DaemonTests" name="test_if_daemons_are_running_on_[kg-topology-CloudEosRR1]" time="0.259" /><testcase classname="tests.daemon.test_daemon.DaemonTests" name="test_if_daemons_are_enabled_on_[kg-topology-CloudEosRR1]" time="0.263" /><testcase classname="tests.dns.test_dns.DNSTests" name="test_if_dns_resolves_on_[kg-topology-CloudEosRR1]" time="1.427" /><testcase classname="tests.dns.test_dns.DNSTests" name="test_if_dns_servers_are_reachable_on_[kg-topology-CloudEosRR1]" time="4.876"><failure message="assert [False] == [True]&#10;  At index 0 diff: False != True&#10;  Full diff:&#10;  - [True]&#10;  + [False]">self = &lt;vane.bin.tests.dns.test_dns.DNSTests object at 0x7f6f349b6070&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.242.29:443//command-api)), 'name': 'kg-topology-...TEM:\n  name=system default-action=none\nAccounting method list for DOT1X:\n  name=dot1x default-action=none\n'}, ...}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_dns_servers_are_reachable_on_(self, dut, tests_definitions):
        """ Verifies DNS servers are reachable via ping
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
        dns_servers = tops.test_parameters["dns_servers"]
        dns_vrf = tops.test_parameters["dns_vrf"]
    
        for dns_server in dns_servers:
            if dns_vrf:
                show_cmd = f"ping vrf {dns_vrf} ip {dns_server}"
            else:
                show_cmd = f"ping {dns_server}"
    
            tops.return_show_cmd(show_cmd)
            tops.actual_output = 'bytes from' in tops.show_cmd_txt
            tops.test_result = tops.actual_output is tops.expected_output
    
            tops.output_msg += (f"\nOn router |{tops.dut_name}|, verifying NTP "
                                f"server reachability for |{dns_server}| is "
                                f"|{tops.test_result}|.\n")
    
            tops.comment += (f'TEST NTP servers are reachable on |{tops.dut_name}| '
                             f'GIVEN server |{dns_server}|.\n'
                             'WHEN exception is |bytes from| '
                             'string.\n'
                             f'THEN test case result is |{tops.test_result}|.\n'
                             f'OUTPUT of |{show_cmd}| is :\n\n{tops.show_cmd_txt}.\n')
    
            tops.actual_results.append(tops.actual_output)
            tops.expected_results.append(tops.expected_output)
    
        tops.actual_output, tops.expected_output = tops.actual_results, tops.expected_results
        tops.post_testcase()
    
&gt;       assert tops.actual_results == tops.expected_results
E       assert [False] == [True]
E         At index 0 diff: False != True
E         Full diff:
E         - [True]
E         + [False]

tests/dns/test_dns.py:131: AssertionError</failure></testcase><testcase classname="tests.dns.test_dns.DNSTests" name="test_dns_configuration_on_[kg-topology-CloudEosRR1]" time="0.731" /><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_temp_is_in_spec_on_[kg-topology-CloudEosRR1]" time="0.255" /><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_sensors_temp_is_in_spec_on_[kg-topology-CloudEosRR1]" time="0.256" /><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_power_are_in_spec_on_[kg-topology-CloudEosRR1]" time="0.263" /><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_cooling_is_in_spec_on_[kg-topology-CloudEosRR1]" time="0.272" /><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_fan_status_is_in_spec_on_[kg-topology-CloudEosRR1]" time="0.269" /><testcase classname="tests.extension.test_extension.ExtensionsTests" name="test_if_extensions_are_installed_on_[kg-topology-CloudEosRR1]" time="0.272" /><testcase classname="tests.extension.test_extension.ExtensionsTests" name="test_if_extensions_are_erroring_on_[kg-topology-CloudEosRR1]" time="0.273" /><testcase classname="tests.filesystem.test_filesystem.FileSystemTests" name="test_if_files_on_[kg-topology-CloudEosRR1]" time="0.955" /><testcase classname="tests.host.test_host.HostTests" name="test_if_hostname_is_correcet_on_[kg-topology-CloudEosRR1]" time="0.357" /><testcase classname="tests.interface.test_interface.InterfaceStatusTests" name="test_if_intf_protocol_status_is_connected_on_[kg-topology-CloudEosRR1]" time="0.280" /><testcase classname="tests.interface.test_interface.InterfaceStatusTests" name="test_if_intf_link_status_is_connected_on_[kg-topology-CloudEosRR1]" time="0.277" /><testcase classname="tests.interface.test_interface.InterfacePhyTests" name="test_if_intf_phy_status_connected_on_[kg-topology-CloudEosRR1]" time="0.343" /><testcase classname="tests.interface.test_interface.InterfaceCountersTests" name="test_if_interface_errors_on_[kg-topology-CloudEosRR1]" time="0.274" /><testcase classname="tests.interface.test_interface.InterfaceCountersTests" name="test_interface_utilization_on_[kg-topology-CloudEosRR1]" time="0.281" /><testcase classname="tests.interface.test_interface.InterfaceDiscardTests" name="test_if_intf_out_counters_are_discarding_on_[kg-topology-CloudEosRR1]" time="0.284" /><testcase classname="tests.interface.test_interface.InterfaceDiscardTests" name="test_if_intf_in_counters_are_discarding_on_[kg-topology-CloudEosRR1]" time="0.267" /><testcase classname="tests.interface.test_interface.InterfaceMtuTests" name="test_if_intf_mtu_is_correct_on_[kg-topology-CloudEosRR1]" time="0.275"><failure message="assert [1500] == [10178]&#10;  At index 0 diff: 1500 != 10178&#10;  Full diff:&#10;  - [10178]&#10;  + [1500]">self = &lt;vane.bin.tests.interface.test_interface.InterfaceMtuTests object at 0x7f6f34739520&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.242.29:443//command-api)), 'name': 'kg-topology-...TEM:\n  name=system default-action=none\nAccounting method list for DOT1X:\n  name=dot1x default-action=none\n'}, ...}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_mtu_is_correct_on_(self, dut, tests_definitions):
        """  Verify the interfaces of interest have no inDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
        print(f"\nOn router |{tops.dut_name}|:")
    
        for interface in tops.interface_list:
            interface_name = interface['interface_name'].replace(" ", "")
            int_ptr = dut["output"][tops.show_cmd]['json']['interfaces']
            tops.actual_output = int_ptr[interface_name]['mtu']
            tops.test_result = tops.actual_output == tops.expected_output
    
            tops.output_msg += (f"On interface |{interface_name}|: interface "
                                f"MTU is |{tops.actual_output}|, correct MTU is "
                                f"|{tops.expected_output}|.\n\n")
            tops.comment += (f'TEST if interface |{interface_name}| MTU is correct '
                             f'on |{tops.dut_name}|.\n'
                             f'GIVEN MTU of |{tops.expected_output}|.\n'
                             f'WHEN interface MTU is |{tops.actual_output}|.\n'
                             f'THEN test case result is |{tops.test_result}|.\n\n')
    
            tops.actual_results.append(tops.actual_output)
            tops.expected_results.append(tops.expected_output)
    
        tops.comment += (f'OUTPUT of |{tops.show_cmd}| is :\n\n{tops.show_cmd_txt}.\n')
        print(f"{tops.output_msg}\n{tops.comment}")
    
        tops.actual_output, tops.expected_output = tops.actual_results, tops.expected_results
        tops.post_testcase()
    
&gt;       assert tops.actual_results == tops.expected_results
E       assert [1500] == [10178]
E         At index 0 diff: 1500 != 10178
E         Full diff:
E         - [10178]
E         + [1500]

tests/interface/test_interface.py:605: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpTests" name="test_if_lldp_rx_is_enabled_on_[kg-topology-CloudEosRR1]" time="0.281" /><testcase classname="tests.lldp.test_lldp.LldpTests" name="test_if_lldp_tx_is_enabled_on_[kg-topology-CloudEosRR1]" time="0.261" /><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_system_name_is_correct_on_[kg-topology-CloudEosRR1]" time="0.252" /><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_max_frame_size_is_correct_on_[kg-topology-CloudEosRR1]" time="0.272"><failure message="assert [9236] == [10200]&#10;  At index 0 diff: 9236 != 10200&#10;  Full diff:&#10;  - [10200]&#10;  + [9236]">self = &lt;vane.bin.tests.lldp.test_lldp.LldpLocalInfoTests object at 0x7f6f34749e50&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.242.29:443//command-api)), 'name': 'kg-topology-...TEM:\n  name=system default-action=none\nAccounting method list for DOT1X:\n  name=dot1x default-action=none\n'}, ...}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_max_frame_size_is_correct_on_(self, dut, tests_definitions):
        """  Verify show lldp local-info maxFrameSize is correct
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
        print(f"\nOn router |{tops.dut_name}|:")
    
        for interface in tops.interface_list:
            interface_name = interface['interface_name'].replace(" ", "")
            int_ptr = dut["output"][tops.show_cmd]["json"]['localInterfaceInfo']
            tops.actual_output = int_ptr[interface_name]['maxFrameSize']
    
            tops.output_msg += (f"On interface |{interface_name}|: LLDP local-info "
                                f"maxFrameSize is |{tops.actual_output}|, correct "
                                f"maxFrameSize is |{tops.expected_output}|.\n\n")
            tops.test_result = tops.actual_output == tops.expected_output
    
            tops.comment += (f'TEST if |{tops.dut_name}| LLDP maxFrameSize is correct '
                             f'on interface |{interface_name}|.\n'
                             f'GIVEN LLDP maxFrameSize is |{tops.expected_output}|.\n'
                             f'WHEN LLDP maxFrameSize is |{tops.actual_output}|.\n'
                             f'THEN test case result is |{tops.test_result}|.\n\n')
    
            tops.actual_results.append(tops.actual_output)
            tops.expected_results.append(tops.expected_output)
    
        tops.comment += (f'OUTPUT of |{tops.show_cmd}| is :\n\n{tops.show_cmd_txt}.\n')
        print(f"{tops.output_msg}\n{tops.comment}")
    
        tops.actual_output, tops.expected_output = tops.actual_results, tops.expected_results
        tops.post_testcase()
    
&gt;       assert tops.actual_results == tops.expected_results
E       assert [9236] == [10200]
E         At index 0 diff: 9236 != 10200
E         Full diff:
E         - [10200]
E         + [9236]

tests/lldp/test_lldp.py:203: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_interface_id_is_correct_on_[kg-topology-CloudEosRR1]" time="0.278" /><testcase classname="tests.log.test_logging.LoggingTests" name="test_if_log_messages_appear_on_[kg-topology-CloudEosRR1]" time="0.311" /><testcase classname="tests.memory.test_memory.MemoryTests" name="test_memory_utilization_on_[kg-topology-CloudEosRR1]" time="0.279" /><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_is_synchronized_on_[kg-topology-CloudEosRR1]" time="0.295" /><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_associated_with_peers_on_[kg-topology-CloudEosRR1]" time="0.282" /><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_process_is_running_on_[kg-topology-CloudEosRR1]" time="0.326" /><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_ntp_configuration_on_[kg-topology-CloudEosRR1]" time="0.743" /><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_servers_are_reachable_on_[kg-topology-CloudEosRR1]" time="4.859"><failure message="assert [False] == [True]&#10;  At index 0 diff: False != True&#10;  Full diff:&#10;  - [True]&#10;  + [False]">self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f348a4820&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.242.29:443//command-api)), 'name': 'kg-topology-...TEM:\n  name=system default-action=none\nAccounting method list for DOT1X:\n  name=dot1x default-action=none\n'}, ...}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_ntp_servers_are_reachable_on_(self, dut, tests_definitions):
        """ Verifies DNS servers are reachable via ping
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
        ntp_servers = tops.test_parameters["ntp_servers"]
        ntp_vrf = tops.test_parameters["ntp_vrf"]
    
        for ntp_server in ntp_servers:
            if ntp_vrf:
                show_cmd = f"ping vrf {ntp_vrf} ip {ntp_server}"
            else:
                show_cmd = f"ping {ntp_server}"
    
            tops.return_show_cmd(show_cmd)
            tops.actual_output = 'bytes from' in tops.show_cmd_txt
            tops.test_result = tops.actual_output is tops.expected_output
    
            tops.output_msg += (f"\nOn router |{tops.dut_name}|, verifying NTP "
                                f"server reachability for |{ntp_server}| is "
                                f"|{tops.test_result}|.\n")
    
            tops.comment += (f'TEST NTP servers are reachable on |{tops.dut_name}| '
                             f'GIVEN server |{ntp_server}|.\n'
                             'WHEN exception is |bytes from| '
                             'string.\n'
                             f'THEN test case result is |{tops.test_result}|.\n'
                             f'OUTPUT of |{show_cmd}| is :\n\n{tops.show_cmd_txt}.\n')
    
            tops.actual_results.append(tops.actual_output)
            tops.expected_results.append(tops.expected_output)
    
        tops.actual_output, tops.expected_output = tops.actual_results, tops.expected_results
        tops.post_testcase()
    
&gt;       assert tops.actual_results == tops.expected_results
E       assert [False] == [True]
E         At index 0 diff: False != True
E         Full diff:
E         - [True]
E         + [False]

tests/ntp/test_ntp.py:250: AssertionError</failure></testcase><testcase classname="tests.system.test_system.CrashTests" name="test_if_there_is_agents_have_crashed_on_[kg-topology-CloudEosRR1]" time="0.640" /><testcase classname="tests.system.test_system.SystemTests" name="test_if_eos_version_is_correct_on_[kg-topology-CloudEosRR1]" time="0.268"><failure message="AssertionError: assert '4.24.0FX-cloud' == '4.23.1F-clou...eering build)'&#10;  - 4.23.1F-cloud-16179785.jakartarel (engineering build)&#10;  + 4.24.0FX-cloud">self = &lt;vane.bin.tests.system.test_system.SystemTests object at 0x7f6f348c8f10&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.242.29:443//command-api)), 'name': 'kg-topology-...TEM:\n  name=system default-action=none\nAccounting method list for DOT1X:\n  name=dot1x default-action=none\n'}, ...}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_eos_version_is_correct_on_(self, dut, tests_definitions):
        """ Verifies EOS version running on the device
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
        tops.actual_output = dut["output"][tops.show_cmd]["json"]["version"]
        tops.test_result = tops.actual_output == tops.expected_output
    
        tops.output_msg = (f"On router |{tops.dut_name}| EOS version is "
                           f"|{tops.actual_output}%|, version should be "
                           f"|{tops.expected_output}%|")
        tops.comment = ('TEST EOS version running on the device on '
                        f'|{tops.dut_name}|.\n'
                        f'GIVEN version is |{tops.expected_output}|.\n'
                        f'WHEN version is |{tops.actual_output}|.\n'
                        f'THEN test case result is |{tops.test_result}|.\n'
                        f'OUTPUT of |{tops.show_cmd}| is:\n\n{tops.show_cmd_txt}')
    
        print(f"{tops.output_msg}\n{tops.comment}")
    
        tops.post_testcase()
    
&gt;       assert tops.actual_output == tops.expected_output
E       AssertionError: assert '4.24.0FX-cloud' == '4.23.1F-clou...eering build)'
E         - 4.23.1F-cloud-16179785.jakartarel (engineering build)
E         + 4.24.0FX-cloud

tests/system/test_system.py:116: AssertionError</failure></testcase><testcase classname="tests.tacacs.test_tacacs.TacacsTests" name="test_if_tacacs_is_sending_messages_on_[kg-topology-CloudEosRR1]" time="0.252" /><testcase classname="tests.tacacs.test_tacacs.TacacsTests" name="test_if_tacacs_is_receiving_messages_on_[kg-topology-CloudEosRR1]" time="0.254" /><testcase classname="tests.users.test_users.UsersTests" name="test_if_usernames_are_configured_on_[kg-topology-CloudEosRR1]" time="0.259" /><testcase classname="tests.ztp.test_ztp.ZTPTests" name="test_if_zerotouch_is_disabled_on_[kg-topology-CloudEosRR1]" time="0.284" /><testcase classname="tests.ztp.test_ztp.ZTPTests" name="test_for_zerotouch_config_file_on_[kg-topology-CloudEosRR1]" time="0.254" /><testcase classname="tests.test_pytest.PyTestTests" name="test_assert_true[kg-topology-CloudEosRR2]" time="0.002" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_authentication_counters_are_incrementing_on_[kg-topology-CloudEosRR2]" time="0.001"><skipped type="pytest.skip" message="No AAA setup on DUTs">/project/vane/bin/tests/aaa/test_aaa.py:51: No AAA setup on DUTs</skipped></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_aaa_session_logging_is_working_on_[kg-topology-CloudEosRR2]" time="0.252" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_commands_authorization_methods_set_on_[kg-topology-CloudEosRR2]" time="0.253" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_exec_authorization_methods_set_on_[kg-topology-CloudEosRR2]" time="0.257" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_default_login_authentication_methods_set_on_[kg-topology-CloudEosRR2]" time="0.265" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_login_authentication_methods_set_on_[kg-topology-CloudEosRR2]" time="0.247" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_dot1x_authentication_methods_set_on_[kg-topology-CloudEosRR2]" time="0.251" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_enable_authentication_methods_set_on_[kg-topology-CloudEosRR2]" time="0.258" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_system_accounting_methods_set_on_[kg-topology-CloudEosRR2]" time="0.246" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_exec_accounting_methods_set_on_[kg-topology-CloudEosRR2]" time="0.250" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_priviledge_accounting_methods_set_on_[kg-topology-CloudEosRR2]" time="0.252" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_dot1x_accounting_methods_set_on_[kg-topology-CloudEosRR2]" time="0.250" /><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_is_running_on_[kg-topology-CloudEosRR2]" time="0.258" /><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_port_is_correct_on_[kg-topology-CloudEosRR2]" time="0.274" /><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_is_enabled_on_[kg-topology-CloudEosRR2]" time="0.311" /><testcase classname="tests.api.test_api.APITests" name="test_if_management_http_api_server_is_running_on_[kg-topology-CloudEosRR2]" time="0.288" /><testcase classname="tests.api.test_api.APITests" name="test_if_management_local_http_api_server_is_running_on_[kg-topology-CloudEosRR2]" time="0.282" /><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_1_sec_cpu_utlization_on_[kg-topology-CloudEosRR2]" time="0.550" /><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_1_min_cpu_utlization_on_[kg-topology-CloudEosRR2]" time="0.539" /><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_5_min_cpu_utlization_on_[kg-topology-CloudEosRR2]" time="0.380" /><testcase classname="tests.daemon.test_daemon.DaemonTests" name="test_if_daemons_are_running_on_[kg-topology-CloudEosRR2]" time="0.276" /><testcase classname="tests.daemon.test_daemon.DaemonTests" name="test_if_daemons_are_enabled_on_[kg-topology-CloudEosRR2]" time="0.259" /><testcase classname="tests.dns.test_dns.DNSTests" name="test_if_dns_resolves_on_[kg-topology-CloudEosRR2]" time="1.530" /><testcase classname="tests.dns.test_dns.DNSTests" name="test_if_dns_servers_are_reachable_on_[kg-topology-CloudEosRR2]" time="4.842"><failure message="assert [False] == [True]&#10;  At index 0 diff: False != True&#10;  Full diff:&#10;  - [True]&#10;  + [False]">self = &lt;vane.bin.tests.dns.test_dns.DNSTests object at 0x7f6f34926a60&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.23.123.34:443//command-api)), 'name': 'kg-topology-C...TEM:\n  name=system default-action=none\nAccounting method list for DOT1X:\n  name=dot1x default-action=none\n'}, ...}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_dns_servers_are_reachable_on_(self, dut, tests_definitions):
        """ Verifies DNS servers are reachable via ping
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
        dns_servers = tops.test_parameters["dns_servers"]
        dns_vrf = tops.test_parameters["dns_vrf"]
    
        for dns_server in dns_servers:
            if dns_vrf:
                show_cmd = f"ping vrf {dns_vrf} ip {dns_server}"
            else:
                show_cmd = f"ping {dns_server}"
    
            tops.return_show_cmd(show_cmd)
            tops.actual_output = 'bytes from' in tops.show_cmd_txt
            tops.test_result = tops.actual_output is tops.expected_output
    
            tops.output_msg += (f"\nOn router |{tops.dut_name}|, verifying NTP "
                                f"server reachability for |{dns_server}| is "
                                f"|{tops.test_result}|.\n")
    
            tops.comment += (f'TEST NTP servers are reachable on |{tops.dut_name}| '
                             f'GIVEN server |{dns_server}|.\n'
                             'WHEN exception is |bytes from| '
                             'string.\n'
                             f'THEN test case result is |{tops.test_result}|.\n'
                             f'OUTPUT of |{show_cmd}| is :\n\n{tops.show_cmd_txt}.\n')
    
            tops.actual_results.append(tops.actual_output)
            tops.expected_results.append(tops.expected_output)
    
        tops.actual_output, tops.expected_output = tops.actual_results, tops.expected_results
        tops.post_testcase()
    
&gt;       assert tops.actual_results == tops.expected_results
E       assert [False] == [True]
E         At index 0 diff: False != True
E         Full diff:
E         - [True]
E         + [False]

tests/dns/test_dns.py:131: AssertionError</failure></testcase><testcase classname="tests.dns.test_dns.DNSTests" name="test_dns_configuration_on_[kg-topology-CloudEosRR2]" time="0.709" /><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_temp_is_in_spec_on_[kg-topology-CloudEosRR2]" time="0.271" /><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_sensors_temp_is_in_spec_on_[kg-topology-CloudEosRR2]" time="0.269" /><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_power_are_in_spec_on_[kg-topology-CloudEosRR2]" time="0.272" /><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_cooling_is_in_spec_on_[kg-topology-CloudEosRR2]" time="0.273" /><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_fan_status_is_in_spec_on_[kg-topology-CloudEosRR2]" time="0.277" /><testcase classname="tests.extension.test_extension.ExtensionsTests" name="test_if_extensions_are_installed_on_[kg-topology-CloudEosRR2]" time="0.278" /><testcase classname="tests.extension.test_extension.ExtensionsTests" name="test_if_extensions_are_erroring_on_[kg-topology-CloudEosRR2]" time="0.276" /><testcase classname="tests.filesystem.test_filesystem.FileSystemTests" name="test_if_files_on_[kg-topology-CloudEosRR2]" time="0.942" /><testcase classname="tests.host.test_host.HostTests" name="test_if_hostname_is_correcet_on_[kg-topology-CloudEosRR2]" time="0.274" /><testcase classname="tests.interface.test_interface.InterfaceStatusTests" name="test_if_intf_protocol_status_is_connected_on_[kg-topology-CloudEosRR2]" time="0.294" /><testcase classname="tests.interface.test_interface.InterfaceStatusTests" name="test_if_intf_link_status_is_connected_on_[kg-topology-CloudEosRR2]" time="0.285" /><testcase classname="tests.interface.test_interface.InterfacePhyTests" name="test_if_intf_phy_status_connected_on_[kg-topology-CloudEosRR2]" time="0.264" /><testcase classname="tests.interface.test_interface.InterfaceCountersTests" name="test_if_interface_errors_on_[kg-topology-CloudEosRR2]" time="0.282" /><testcase classname="tests.interface.test_interface.InterfaceCountersTests" name="test_interface_utilization_on_[kg-topology-CloudEosRR2]" time="0.267" /><testcase classname="tests.interface.test_interface.InterfaceDiscardTests" name="test_if_intf_out_counters_are_discarding_on_[kg-topology-CloudEosRR2]" time="0.292" /><testcase classname="tests.interface.test_interface.InterfaceDiscardTests" name="test_if_intf_in_counters_are_discarding_on_[kg-topology-CloudEosRR2]" time="0.285" /><testcase classname="tests.interface.test_interface.InterfaceMtuTests" name="test_if_intf_mtu_is_correct_on_[kg-topology-CloudEosRR2]" time="0.292"><failure message="assert [1500] == [10178]&#10;  At index 0 diff: 1500 != 10178&#10;  Full diff:&#10;  - [10178]&#10;  + [1500]">self = &lt;vane.bin.tests.interface.test_interface.InterfaceMtuTests object at 0x7f6f34874f40&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.23.123.34:443//command-api)), 'name': 'kg-topology-C...TEM:\n  name=system default-action=none\nAccounting method list for DOT1X:\n  name=dot1x default-action=none\n'}, ...}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_mtu_is_correct_on_(self, dut, tests_definitions):
        """  Verify the interfaces of interest have no inDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
        print(f"\nOn router |{tops.dut_name}|:")
    
        for interface in tops.interface_list:
            interface_name = interface['interface_name'].replace(" ", "")
            int_ptr = dut["output"][tops.show_cmd]['json']['interfaces']
            tops.actual_output = int_ptr[interface_name]['mtu']
            tops.test_result = tops.actual_output == tops.expected_output
    
            tops.output_msg += (f"On interface |{interface_name}|: interface "
                                f"MTU is |{tops.actual_output}|, correct MTU is "
                                f"|{tops.expected_output}|.\n\n")
            tops.comment += (f'TEST if interface |{interface_name}| MTU is correct '
                             f'on |{tops.dut_name}|.\n'
                             f'GIVEN MTU of |{tops.expected_output}|.\n'
                             f'WHEN interface MTU is |{tops.actual_output}|.\n'
                             f'THEN test case result is |{tops.test_result}|.\n\n')
    
            tops.actual_results.append(tops.actual_output)
            tops.expected_results.append(tops.expected_output)
    
        tops.comment += (f'OUTPUT of |{tops.show_cmd}| is :\n\n{tops.show_cmd_txt}.\n')
        print(f"{tops.output_msg}\n{tops.comment}")
    
        tops.actual_output, tops.expected_output = tops.actual_results, tops.expected_results
        tops.post_testcase()
    
&gt;       assert tops.actual_results == tops.expected_results
E       assert [1500] == [10178]
E         At index 0 diff: 1500 != 10178
E         Full diff:
E         - [10178]
E         + [1500]

tests/interface/test_interface.py:605: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpTests" name="test_if_lldp_rx_is_enabled_on_[kg-topology-CloudEosRR2]" time="0.272" /><testcase classname="tests.lldp.test_lldp.LldpTests" name="test_if_lldp_tx_is_enabled_on_[kg-topology-CloudEosRR2]" time="0.258" /><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_system_name_is_correct_on_[kg-topology-CloudEosRR2]" time="0.274" /><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_max_frame_size_is_correct_on_[kg-topology-CloudEosRR2]" time="0.266"><failure message="assert [9236] == [10200]&#10;  At index 0 diff: 9236 != 10200&#10;  Full diff:&#10;  - [10200]&#10;  + [9236]">self = &lt;vane.bin.tests.lldp.test_lldp.LldpLocalInfoTests object at 0x7f6f348738b0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.23.123.34:443//command-api)), 'name': 'kg-topology-C...TEM:\n  name=system default-action=none\nAccounting method list for DOT1X:\n  name=dot1x default-action=none\n'}, ...}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_max_frame_size_is_correct_on_(self, dut, tests_definitions):
        """  Verify show lldp local-info maxFrameSize is correct
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
        print(f"\nOn router |{tops.dut_name}|:")
    
        for interface in tops.interface_list:
            interface_name = interface['interface_name'].replace(" ", "")
            int_ptr = dut["output"][tops.show_cmd]["json"]['localInterfaceInfo']
            tops.actual_output = int_ptr[interface_name]['maxFrameSize']
    
            tops.output_msg += (f"On interface |{interface_name}|: LLDP local-info "
                                f"maxFrameSize is |{tops.actual_output}|, correct "
                                f"maxFrameSize is |{tops.expected_output}|.\n\n")
            tops.test_result = tops.actual_output == tops.expected_output
    
            tops.comment += (f'TEST if |{tops.dut_name}| LLDP maxFrameSize is correct '
                             f'on interface |{interface_name}|.\n'
                             f'GIVEN LLDP maxFrameSize is |{tops.expected_output}|.\n'
                             f'WHEN LLDP maxFrameSize is |{tops.actual_output}|.\n'
                             f'THEN test case result is |{tops.test_result}|.\n\n')
    
            tops.actual_results.append(tops.actual_output)
            tops.expected_results.append(tops.expected_output)
    
        tops.comment += (f'OUTPUT of |{tops.show_cmd}| is :\n\n{tops.show_cmd_txt}.\n')
        print(f"{tops.output_msg}\n{tops.comment}")
    
        tops.actual_output, tops.expected_output = tops.actual_results, tops.expected_results
        tops.post_testcase()
    
&gt;       assert tops.actual_results == tops.expected_results
E       assert [9236] == [10200]
E         At index 0 diff: 9236 != 10200
E         Full diff:
E         - [10200]
E         + [9236]

tests/lldp/test_lldp.py:203: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_interface_id_is_correct_on_[kg-topology-CloudEosRR2]" time="0.283" /><testcase classname="tests.log.test_logging.LoggingTests" name="test_if_log_messages_appear_on_[kg-topology-CloudEosRR2]" time="0.315" /><testcase classname="tests.memory.test_memory.MemoryTests" name="test_memory_utilization_on_[kg-topology-CloudEosRR2]" time="0.312" /><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_is_synchronized_on_[kg-topology-CloudEosRR2]" time="0.276" /><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_associated_with_peers_on_[kg-topology-CloudEosRR2]" time="0.275" /><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_process_is_running_on_[kg-topology-CloudEosRR2]" time="0.457" /><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_ntp_configuration_on_[kg-topology-CloudEosRR2]" time="0.808" /><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_servers_are_reachable_on_[kg-topology-CloudEosRR2]" time="4.814"><failure message="assert [False] == [True]&#10;  At index 0 diff: False != True&#10;  Full diff:&#10;  - [True]&#10;  + [False]">self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f34763bb0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.23.123.34:443//command-api)), 'name': 'kg-topology-C...TEM:\n  name=system default-action=none\nAccounting method list for DOT1X:\n  name=dot1x default-action=none\n'}, ...}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_ntp_servers_are_reachable_on_(self, dut, tests_definitions):
        """ Verifies DNS servers are reachable via ping
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
        ntp_servers = tops.test_parameters["ntp_servers"]
        ntp_vrf = tops.test_parameters["ntp_vrf"]
    
        for ntp_server in ntp_servers:
            if ntp_vrf:
                show_cmd = f"ping vrf {ntp_vrf} ip {ntp_server}"
            else:
                show_cmd = f"ping {ntp_server}"
    
            tops.return_show_cmd(show_cmd)
            tops.actual_output = 'bytes from' in tops.show_cmd_txt
            tops.test_result = tops.actual_output is tops.expected_output
    
            tops.output_msg += (f"\nOn router |{tops.dut_name}|, verifying NTP "
                                f"server reachability for |{ntp_server}| is "
                                f"|{tops.test_result}|.\n")
    
            tops.comment += (f'TEST NTP servers are reachable on |{tops.dut_name}| '
                             f'GIVEN server |{ntp_server}|.\n'
                             'WHEN exception is |bytes from| '
                             'string.\n'
                             f'THEN test case result is |{tops.test_result}|.\n'
                             f'OUTPUT of |{show_cmd}| is :\n\n{tops.show_cmd_txt}.\n')
    
            tops.actual_results.append(tops.actual_output)
            tops.expected_results.append(tops.expected_output)
    
        tops.actual_output, tops.expected_output = tops.actual_results, tops.expected_results
        tops.post_testcase()
    
&gt;       assert tops.actual_results == tops.expected_results
E       assert [False] == [True]
E         At index 0 diff: False != True
E         Full diff:
E         - [True]
E         + [False]

tests/ntp/test_ntp.py:250: AssertionError</failure></testcase><testcase classname="tests.system.test_system.CrashTests" name="test_if_there_is_agents_have_crashed_on_[kg-topology-CloudEosRR2]" time="0.624" /><testcase classname="tests.system.test_system.SystemTests" name="test_if_eos_version_is_correct_on_[kg-topology-CloudEosRR2]" time="0.321"><failure message="AssertionError: assert '4.24.0FX-cloud' == '4.23.1F-clou...eering build)'&#10;  - 4.23.1F-cloud-16179785.jakartarel (engineering build)&#10;  + 4.24.0FX-cloud">self = &lt;vane.bin.tests.system.test_system.SystemTests object at 0x7f6f3477c580&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.23.123.34:443//command-api)), 'name': 'kg-topology-C...TEM:\n  name=system default-action=none\nAccounting method list for DOT1X:\n  name=dot1x default-action=none\n'}, ...}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_eos_version_is_correct_on_(self, dut, tests_definitions):
        """ Verifies EOS version running on the device
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
        tops.actual_output = dut["output"][tops.show_cmd]["json"]["version"]
        tops.test_result = tops.actual_output == tops.expected_output
    
        tops.output_msg = (f"On router |{tops.dut_name}| EOS version is "
                           f"|{tops.actual_output}%|, version should be "
                           f"|{tops.expected_output}%|")
        tops.comment = ('TEST EOS version running on the device on '
                        f'|{tops.dut_name}|.\n'
                        f'GIVEN version is |{tops.expected_output}|.\n'
                        f'WHEN version is |{tops.actual_output}|.\n'
                        f'THEN test case result is |{tops.test_result}|.\n'
                        f'OUTPUT of |{tops.show_cmd}| is:\n\n{tops.show_cmd_txt}')
    
        print(f"{tops.output_msg}\n{tops.comment}")
    
        tops.post_testcase()
    
&gt;       assert tops.actual_output == tops.expected_output
E       AssertionError: assert '4.24.0FX-cloud' == '4.23.1F-clou...eering build)'
E         - 4.23.1F-cloud-16179785.jakartarel (engineering build)
E         + 4.24.0FX-cloud

tests/system/test_system.py:116: AssertionError</failure></testcase><testcase classname="tests.tacacs.test_tacacs.TacacsTests" name="test_if_tacacs_is_sending_messages_on_[kg-topology-CloudEosRR2]" time="0.263" /><testcase classname="tests.tacacs.test_tacacs.TacacsTests" name="test_if_tacacs_is_receiving_messages_on_[kg-topology-CloudEosRR2]" time="0.246" /><testcase classname="tests.users.test_users.UsersTests" name="test_if_usernames_are_configured_on_[kg-topology-CloudEosRR2]" time="0.261" /><testcase classname="tests.ztp.test_ztp.ZTPTests" name="test_if_zerotouch_is_disabled_on_[kg-topology-CloudEosRR2]" time="0.258" /><testcase classname="tests.ztp.test_ztp.ZTPTests" name="test_for_zerotouch_config_file_on_[kg-topology-CloudEosRR2]" time="0.261" /><testcase classname="tests.test_pytest.PyTestTests" name="test_assert_true[kg-topology-CloudEOSEdge1]" time="0.002" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_authentication_counters_are_incrementing_on_[kg-topology-CloudEOSEdge1]" time="0.001"><skipped type="pytest.skip" message="No AAA setup on DUTs">/project/vane/bin/tests/aaa/test_aaa.py:51: No AAA setup on DUTs</skipped></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_aaa_session_logging_is_working_on_[kg-topology-CloudEOSEdge1]" time="0.253"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f34777ca0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_aaa_session_logging_is_working_on_(self,
                                                   dut,
                                                   tests_definitions):
        """ Verify AAA session logging is working by identifying eapi connection
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show users detail'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_commands_authorization_methods_set_on_[kg-topology-CloudEOSEdge1]" time="0.244"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f34702730&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authorization
    def test_if_commands_authorization_methods_set_on_(self,
                                                       dut,
                                                       tests_definitions):
        """ Verify AAA command authorization are method-lists set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        cmd_auth = test_parameters["cmd_auth"]
        expected_output = cmd_auth
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_exec_authorization_methods_set_on_[kg-topology-CloudEOSEdge1]" time="0.290"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f347b2160&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authorization
    def test_if_exec_authorization_methods_set_on_(self,
                                                   dut,
                                                   tests_definitions):
        """ Verify AAA exec authorization are method-lists set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        exec_auth = test_parameters["exec_auth"]
        expected_output = exec_auth
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_default_login_authentication_methods_set_on_[kg-topology-CloudEOSEdge1]" time="0.346"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f347b17f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authentication
    def test_if_default_login_authentication_methods_set_on_(self,
                                                             dut,
                                                             tests_definitions):
        """ Verify AAA default login authentication are method-lists set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        login_auth = test_parameters["login_auth"]
        expected_output = login_auth
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_login_authentication_methods_set_on_[kg-topology-CloudEOSEdge1]" time="0.286"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f346ae460&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authentication
    def test_if_login_authentication_methods_set_on_(self,
                                                     dut,
                                                     tests_definitions):
        """ Verify AAA login authentication are method-lists set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        login_auth = test_parameters["login_auth"]
        expected_output = login_auth
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_dot1x_authentication_methods_set_on_[kg-topology-CloudEOSEdge1]" time="0.336"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f34695b20&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authentication
    def test_if_dot1x_authentication_methods_set_on_(self,
                                                     dut,
                                                     tests_definitions):
        """ Verify AAA dot1x authentication are method-lists set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        dot1x_auth = test_parameters["dot1x_auth"]
        expected_output = dot1x_auth
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_enable_authentication_methods_set_on_[kg-topology-CloudEOSEdge1]" time="0.272"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f348330d0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authentication
    def test_if_enable_authentication_methods_set_on_(self,
                                                      dut,
                                                      tests_definitions):
        """ Verify AAA enable authentication method-lists are set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        enable_auth = test_parameters["enable_auth"]
        expected_output = enable_auth
    
        logging.info('TEST is enable authentication methods list set correct '
                     f'on |{dut_name}| ')
        logging.info('GIVEN enable authentication method list: '
                     f'|{enable_auth}|')
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_system_accounting_methods_set_on_[kg-topology-CloudEOSEdge1]" time="0.287"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f34838c40&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.accounting
    def test_if_system_accounting_methods_set_on_(self,
                                                  dut,
                                                  tests_definitions):
        """ Verify AAA system accounting method-lists are set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        default_acct = test_parameters["default_acct"]
        console_acct = test_parameters["console_acct"]
        expected_output = [default_acct, console_acct]
    
        logging.info(f'TEST is system accounting methods list set correct '
                     f'on |{dut_name}| ')
        logging.info(f'GIVEN default system accounting method list: '
                     f'|{default_acct}| and console system accounting method'
                     f'list: |{console_acct}|')
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:455: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_exec_accounting_methods_set_on_[kg-topology-CloudEOSEdge1]" time="0.290"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f347089a0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.accounting
    def test_if_exec_accounting_methods_set_on_(self, dut, tests_definitions):
        """ Verify AAA exec accounting method-lists are set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        default_acct = test_parameters["default_acct"]
        console_acct = test_parameters["console_acct"]
        expected_output = [default_acct, console_acct]
    
        logging.info(f'TEST is exec accounting methods list set correct '
                     f'on |{dut_name}| ')
        logging.info(f'GIVEN exec system accounting method list: '
                     f'|{default_acct}| and exec system accounting method'
                     f'list: |{console_acct}|')
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:503: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_priviledge_accounting_methods_set_on_[kg-topology-CloudEOSEdge1]" time="0.282"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f346f2520&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.accounting
    def test_if_priviledge_accounting_methods_set_on_(self,
                                                      dut,
                                                      tests_definitions):
        """ Verify AAA priviledge accounting method-lists are set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        default_acct = test_parameters["default_acct"]
        console_acct = test_parameters["console_acct"]
        expected_output = [default_acct, console_acct]
    
        logging.info(f'TEST is priviledge accounting methods list set correct '
                     f'on |{dut_name}| ')
        logging.info(f'GIVEN priviledge system accounting method list: '
                     f'|{default_acct}| and priviledge system accounting '
                     f'method list: |{console_acct}|')
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_dot1x_accounting_methods_set_on_[kg-topology-CloudEOSEdge1]" time="0.284"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f346cd610&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.accounting
    def test_if_dot1x_accounting_methods_set_on_(self, dut, tests_definitions):
        """ Verify AAA dot1x accounting method-lists are set correct
    
             Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        default_acct = test_parameters["default_acct"]
        console_acct = test_parameters["console_acct"]
        expected_output = [default_acct, console_acct]
    
        logging.info(f'TEST is dot1x accounting methods list set correct on '
                     f'|{dut_name}|')
        logging.info(f'GIVEN dot1x system accounting method list: '
                     f'|{default_acct}| and dot1x system accounting method'
                     f'list: |{console_acct}|')
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_is_running_on_[kg-topology-CloudEOSEdge1]" time="0.284"><failure message="AssertionError">self = &lt;vane.bin.tests.api.test_api.APITests object at 0x7f6f34512460&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_management_https_api_server_is_running_on_(self,
                                                           dut,
                                                           tests_definitions):
      """ Verify management api https server is running
           Args:
            dut (dict): Encapsulates dut details including name, connection
            tests_definitions (dict): Test parameters
      """
    
&gt;     tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/api/test_api.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34512c10&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_port_is_correct_on_[kg-topology-CloudEOSEdge1]" time="0.277"><failure message="AssertionError">self = &lt;vane.bin.tests.api.test_api.APITests object at 0x7f6f347cd4c0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_management_https_api_server_port_is_correct_on_(self,
                                                                dut,
                                                                tests_definitions):
      """ Verify https server is enabled on port 443
           Args:
            dut (dict): Encapsulates dut details including name, connection
            tests_definitions (dict): Test parameters
      """
    
&gt;     tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/api/test_api.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3466d2b0&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_is_enabled_on_[kg-topology-CloudEOSEdge1]" time="0.285"><failure message="AssertionError">self = &lt;vane.bin.tests.api.test_api.APITests object at 0x7f6f3466d1f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_management_https_api_server_is_enabled_on_(self,
                                                           dut,
                                                           tests_definitions):
      """ Verify management api https server is enabled
           Args:
            dut (dict): Encapsulates dut details including name, connection
            tests_definitions (dict): Test parameters
      """
    
&gt;     tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/api/test_api.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f347f54f0&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.api.test_api.APITests" name="test_if_management_http_api_server_is_running_on_[kg-topology-CloudEOSEdge1]" time="0.308"><failure message="AssertionError">self = &lt;vane.bin.tests.api.test_api.APITests object at 0x7f6f3459ea60&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_management_http_api_server_is_running_on_(self,
                                                          dut,
                                                          tests_definitions):
      """ Verify management api http server is not running
           Args:
            dut (dict): Encapsulates dut details including name, connection
            tests_definitions (dict): Test parameters
      """
    
&gt;     tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/api/test_api.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f346e2700&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.api.test_api.APITests" name="test_if_management_local_http_api_server_is_running_on_[kg-topology-CloudEOSEdge1]" time="0.284"><failure message="AssertionError">self = &lt;vane.bin.tests.api.test_api.APITests object at 0x7f6f345faeb0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_management_local_http_api_server_is_running_on_(self,
                                                                dut,
                                                                tests_definitions):
      """ Verify management api local httpserver is not running
           Args:
            dut (dict): Encapsulates dut details including name, connection
            tests_definitions (dict): Test parameters
      """
    
&gt;     tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/api/test_api.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f345fa8e0&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_1_sec_cpu_utlization_on_[kg-topology-CloudEOSEdge1]" time="0.274"><failure message="AssertionError">self = &lt;vane.bin.tests.cpu.test_cpu.CPUTests object at 0x7f6f345d3ac0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_1_sec_cpu_utlization_on_(self, dut, tests_definitions):
        """ Verify 1 second CPU % is under specificied value
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/cpu/test_cpu.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f346274f0&gt;, show_cmd = 'show processes'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_1_min_cpu_utlization_on_[kg-topology-CloudEOSEdge1]" time="0.323"><failure message="AssertionError">self = &lt;vane.bin.tests.cpu.test_cpu.CPUTests object at 0x7f6f345c09d0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_1_min_cpu_utlization_on_(self, dut, tests_definitions):
        """ Verify 1 minute CPU % is under specificied value
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/cpu/test_cpu.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3469d610&gt;, show_cmd = 'show processes'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_5_min_cpu_utlization_on_[kg-topology-CloudEOSEdge1]" time="0.516"><failure message="AssertionError">self = &lt;vane.bin.tests.cpu.test_cpu.CPUTests object at 0x7f6f346abca0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_5_min_cpu_utlization_on_(self, dut, tests_definitions):
        """ Verify 5 minute CPU % is under specificied value
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/cpu/test_cpu.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3464d670&gt;, show_cmd = 'show processes'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.daemon.test_daemon.DaemonTests" name="test_if_daemons_are_running_on_[kg-topology-CloudEOSEdge1]" time="0.454"><failure message="AssertionError">self = &lt;vane.bin.tests.daemon.test_daemon.DaemonTests object at 0x7f6f3466d2b0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_daemons_are_running_on_(self, dut, tests_definitions):
        """ Verify a list of daemons are running on DUT
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/daemon/test_daemon.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3466d700&gt;, show_cmd = 'show daemon'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.daemon.test_daemon.DaemonTests" name="test_if_daemons_are_enabled_on_[kg-topology-CloudEOSEdge1]" time="0.531"><failure message="AssertionError">self = &lt;vane.bin.tests.daemon.test_daemon.DaemonTests object at 0x7f6f346b9d90&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_daemons_are_enabled_on_(self, dut, tests_definitions):
        """ Verify a list of daemons are enabled on DUT
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/daemon/test_daemon.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3464d070&gt;, show_cmd = 'show daemon'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.dns.test_dns.DNSTests" name="test_if_dns_resolves_on_[kg-topology-CloudEOSEdge1]" time="0.371"><failure message="AssertionError">self = &lt;vane.bin.tests.dns.test_dns.DNSTests object at 0x7f6f34704850&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_dns_resolves_on_(self, dut, tests_definitions):
        """ Verify DNS is running by performing pings and verifying name resolution
    
             Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/dns/test_dns.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34610e50&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.dns.test_dns.DNSTests" name="test_if_dns_servers_are_reachable_on_[kg-topology-CloudEOSEdge1]" time="0.312"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 11.201.12.2"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 11.201.12.2"], "format": "json"}, "id": "140115639903856"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 11.201.12.2"], "format": "json"}, "id": "140115639903856"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.129.78.225\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 148\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.dns.test_dns.DNSTests object at 0x7f6f34610430&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_dns_servers_are_reachable_on_(self, dut, tests_definitions):
        """ Verifies DNS servers are reachable via ping
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
        dns_servers = tops.test_parameters["dns_servers"]
        dns_vrf = tops.test_parameters["dns_vrf"]
    
        for dns_server in dns_servers:
            if dns_vrf:
                show_cmd = f"ping vrf {dns_vrf} ip {dns_server}"
            else:
                show_cmd = f"ping {dns_server}"
    
&gt;           tops.return_show_cmd(show_cmd)

tests/dns/test_dns.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:723: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 11.201.12.2"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.dns.test_dns.DNSTests" name="test_dns_configuration_on_[kg-topology-CloudEOSEdge1]" time="0.679"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section name-server"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section name-server"], "format": "json"}, "id": "140115639903856"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section name-server"], "format": "json"}, "id": "140115639903856"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.129.78.225\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 171\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.dns.test_dns.DNSTests object at 0x7f6f345457f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_dns_configuration_on_(self, dut, tests_definitions):
        """ Verifies DNS configuration matches the recommended practices
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
&gt;       tops.return_show_cmd("show running-config section name-server")

tests/dns/test_dns.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:723: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section name-server"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_temp_is_in_spec_on_[kg-topology-CloudEOSEdge1]" time="0.637"><failure message="KeyError: 'show version'">self = &lt;vane.bin.tests.environment.test_environment.EnvironmentTests object at 0x7f6f3451de50&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_system_environment_temp_is_in_spec_on_(self,
                                                        dut,
                                                        tests_definitions):
        """ Verify system temperature environmentals are functional within spec
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
&gt;       if not tests_tools.verify_veos(dut):

tests/environment/test_environment.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_veos(dut):
        """ Verify DUT is a VEOS instance
    
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        show_cmd = "show version"
    
        veos_bool = False
&gt;       veos = dut["output"][show_cmd]['json']['modelName']
E       KeyError: 'show version'

tests_tools.py:456: KeyError</failure></testcase><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_sensors_temp_is_in_spec_on_[kg-topology-CloudEOSEdge1]" time="0.828"><failure message="KeyError: 'show version'">self = &lt;vane.bin.tests.environment.test_environment.EnvironmentTests object at 0x7f6f345ced00&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_sensors_temp_is_in_spec_on_(self, dut, tests_definitions):
        """ Verify system temperature sensors environmentals are functional within spec
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
&gt;       if not tests_tools.verify_veos(dut):

tests/environment/test_environment.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_veos(dut):
        """ Verify DUT is a VEOS instance
    
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        show_cmd = "show version"
    
        veos_bool = False
&gt;       veos = dut["output"][show_cmd]['json']['modelName']
E       KeyError: 'show version'

tests_tools.py:456: KeyError</failure></testcase><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_power_are_in_spec_on_[kg-topology-CloudEOSEdge1]" time="0.338"><failure message="KeyError: 'show version'">self = &lt;vane.bin.tests.environment.test_environment.EnvironmentTests object at 0x7f6f345161c0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_system_environment_power_are_in_spec_on_(self,
                                                         dut,
                                                         tests_definitions):
        """ Verify system power environmentals are functional within spec
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
&gt;       if not tests_tools.verify_veos(dut):

tests/environment/test_environment.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_veos(dut):
        """ Verify DUT is a VEOS instance
    
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        show_cmd = "show version"
    
        veos_bool = False
&gt;       veos = dut["output"][show_cmd]['json']['modelName']
E       KeyError: 'show version'

tests_tools.py:456: KeyError</failure></testcase><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_cooling_is_in_spec_on_[kg-topology-CloudEOSEdge1]" time="0.358"><failure message="AssertionError">self = &lt;vane.bin.tests.environment.test_environment.EnvironmentTests object at 0x7f6f3448b430&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_system_environment_cooling_is_in_spec_on_(self,
                                                          dut,
                                                          tests_definitions):
        """ Verify system cooling environmentals are functional within spec
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/environment/test_environment.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34483e80&gt;, show_cmd = 'show system environment cooling'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_fan_status_is_in_spec_on_[kg-topology-CloudEOSEdge1]" time="0.348"><failure message="AssertionError">self = &lt;vane.bin.tests.environment.test_environment.EnvironmentTests object at 0x7f6f344832e0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...utput': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling', ...}]}, ...]}

    def test_if_fan_status_is_in_spec_on_(self, dut, tests_definitions):
        """ Verify system cooling environmentals are functional within spec
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/environment/test_environment.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34602e20&gt;, show_cmd = 'show system environment cooling'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.extension.test_extension.ExtensionsTests" name="test_if_extensions_are_installed_on_[kg-topology-CloudEOSEdge1]" time="0.373"><failure message="AssertionError">self = &lt;vane.bin.tests.extension.test_extension.ExtensionsTests object at 0x7f6f3443f4f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_extensions_are_installed_on_(self, dut, tests_definitions):
        """ Verify a list of extension are installed on a DUT
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/extension/test_extension.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f345bf310&gt;, show_cmd = 'show extensions'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.extension.test_extension.ExtensionsTests" name="test_if_extensions_are_erroring_on_[kg-topology-CloudEOSEdge1]" time="0.377"><failure message="AssertionError">self = &lt;vane.bin.tests.extension.test_extension.ExtensionsTests object at 0x7f6f345981f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_extensions_are_erroring_on_(self, dut, tests_definitions):
        """ Verify a list of extension are not erroring on a DUT
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/extension/test_extension.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f345bf6d0&gt;, show_cmd = 'show extensions'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.filesystem.test_filesystem.FileSystemTests" name="test_if_files_on_[kg-topology-CloudEOSEdge1]" time="0.435"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show file information flash:startup-config"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show file information flash:startup-config"], "format": "json"}, "id": "140115639903856"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show file information flash:startup-config"], "format": "json"}, "id": "140115639903856"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.129.78.225\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 174\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.filesystem.test_filesystem.FileSystemTests object at 0x7f6f34248be0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_files_on_(self, dut, tests_definitions):
        """ Verify filesystem is correct and expected files are present
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
        files = tops.test_parameters["files"]
    
        for file_name in files:
            show_cmd = f"show file information {file_name}"
&gt;           show_output, show_cmd_txt = tests_tools.return_show_cmd(show_cmd,
                                                                    dut,
                                                                    tops.test_case,
                                                                    LOG_FILE)

tests/filesystem/test_filesystem.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:290: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show file information flash:startup-config"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.host.test_host.HostTests" name="test_if_hostname_is_correcet_on_[kg-topology-CloudEOSEdge1]" time="0.587"><failure message="AssertionError">self = &lt;vane.bin.tests.host.test_host.HostTests object at 0x7f6f3446d5e0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_hostname_is_correcet_on_(self, dut, tests_definitions):
        """ Verify hostname is set on device is correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/host/test_host.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f344808b0&gt;, show_cmd = 'show hostname'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceStatusTests" name="test_if_intf_protocol_status_is_connected_on_[kg-topology-CloudEOSEdge1]" time="0.573"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceStatusTests object at 0x7f6f34232820&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_protocol_status_is_connected_on_(self,
                                                      dut,
                                                      tests_definitions):
        """ Verify the interfaces of interest protocol statuses are up
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f344570d0&gt;, show_cmd = 'show interfaces status'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceStatusTests" name="test_if_intf_link_status_is_connected_on_[kg-topology-CloudEOSEdge1]" time="0.659"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceStatusTests object at 0x7f6f343b5d60&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_link_status_is_connected_on_(self,
                                                  dut,
                                                  tests_definitions):
        """ Verify the interfaces of interest link statuses are up
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f343b5730&gt;, show_cmd = 'show interfaces status'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfacePhyTests" name="test_if_intf_phy_status_connected_on_[kg-topology-CloudEOSEdge1]" time="0.592"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfacePhyTests object at 0x7f6f342cdcd0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_phy_status_connected_on_(self,
                                              dut,
                                              tests_definitions):
        """ Verify the interfaces of interest physical state is link up
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f344c37c0&gt;, show_cmd = 'show interfaces phy detail'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceCountersTests" name="test_if_interface_errors_on_[kg-topology-CloudEOSEdge1]" time="0.699"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceCountersTests object at 0x7f6f3455bd00&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_interface_errors_on_(self, dut, tests_definitions):
        """  Verify the interfaces of interest have no inDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:622: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34232c40&gt;, show_cmd = 'show interfaces'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceCountersTests" name="test_interface_utilization_on_[kg-topology-CloudEOSEdge1]" time="0.558"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceCountersTests object at 0x7f6f34456f10&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_interface_utilization_on_(self, dut, tests_definitions):
        """  Verify the interfaces of interest have no inDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3421aca0&gt;, show_cmd = 'show interfaces'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceDiscardTests" name="test_if_intf_out_counters_are_discarding_on_[kg-topology-CloudEOSEdge1]" time="0.512"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceDiscardTests object at 0x7f6f3421a5b0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_out_counters_are_discarding_on_(self,
                                                     dut,
                                                     tests_definitions):
        """  Verify the interfaces of interest have no outDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:492: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34572fa0&gt;, show_cmd = 'show interfaces counters discards'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceDiscardTests" name="test_if_intf_in_counters_are_discarding_on_[kg-topology-CloudEOSEdge1]" time="0.741"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceDiscardTests object at 0x7f6f34266c70&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_in_counters_are_discarding_on_(self,
                                                    dut,
                                                    tests_definitions):
        """  Verify the interfaces of interest have no inDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:532: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34493ee0&gt;, show_cmd = 'show interfaces counters discards'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceMtuTests" name="test_if_intf_mtu_is_correct_on_[kg-topology-CloudEOSEdge1]" time="0.453"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceMtuTests object at 0x7f6f34402f10&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_mtu_is_correct_on_(self, dut, tests_definitions):
        """  Verify the interfaces of interest have no inDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:577: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f344b4580&gt;, show_cmd = 'show interfaces'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpTests" name="test_if_lldp_rx_is_enabled_on_[kg-topology-CloudEOSEdge1]" time="0.571"><failure message="AssertionError">self = &lt;vane.bin.tests.lldp.test_lldp.LldpTests object at 0x7f6f345670d0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_rx_is_enabled_on_(self, dut, tests_definitions):
        """  Verify LLDP receive is enabled on interesting interfaces
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/lldp/test_lldp.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34229bb0&gt;, show_cmd = 'show lldp'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpTests" name="test_if_lldp_tx_is_enabled_on_[kg-topology-CloudEOSEdge1]" time="0.667"><failure message="AssertionError">self = &lt;vane.bin.tests.lldp.test_lldp.LldpTests object at 0x7f6f34575d90&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_tx_is_enabled_on_(self, dut, tests_definitions):
        """  Verify LLDP transmit is enabled on interesting interfaces
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/lldp/test_lldp.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34328310&gt;, show_cmd = 'show lldp'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_system_name_is_correct_on_[kg-topology-CloudEOSEdge1]" time="0.369"><failure message="AssertionError">self = &lt;vane.bin.tests.lldp.test_lldp.LldpLocalInfoTests object at 0x7f6f3449b670&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_system_name_is_correct_on_(self, dut, tests_definitions):
        """  Verify show lldp local-info hostname is the system's name
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/lldp/test_lldp.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3449b340&gt;, show_cmd = 'show lldp local-info'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_max_frame_size_is_correct_on_[kg-topology-CloudEOSEdge1]" time="0.323"><failure message="AssertionError">self = &lt;vane.bin.tests.lldp.test_lldp.LldpLocalInfoTests object at 0x7f6f343b6220&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_max_frame_size_is_correct_on_(self, dut, tests_definitions):
        """  Verify show lldp local-info maxFrameSize is correct
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/lldp/test_lldp.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f342434c0&gt;, show_cmd = 'show lldp local-info'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_interface_id_is_correct_on_[kg-topology-CloudEOSEdge1]" time="0.321"><failure message="AssertionError">self = &lt;vane.bin.tests.lldp.test_lldp.LldpLocalInfoTests object at 0x7f6f342435e0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_interface_id_is_correct_on_(self, dut, tests_definitions):
        """  Verify show lldp local-info interfaceIdType is correct
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/lldp/test_lldp.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34237400&gt;, show_cmd = 'show lldp local-info'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.log.test_logging.LoggingTests" name="test_if_log_messages_appear_on_[kg-topology-CloudEOSEdge1]" time="0.291"><failure message="AssertionError">self = &lt;vane.bin.tests.log.test_logging.LoggingTests object at 0x7f6f34255460&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_log_messages_appear_on_(self, dut, tests_definitions):
        """ Verify local log messages
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/log/test_logging.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3438b340&gt;, show_cmd = 'show logging'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.memory.test_memory.MemoryTests" name="test_memory_utilization_on_[kg-topology-CloudEOSEdge1]" time="0.301"><failure message="AssertionError">self = &lt;vane.bin.tests.memory.test_memory.MemoryTests object at 0x7f6f345851f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_memory_utilization_on_(self, dut, tests_definitions):
        """ Verify memory is not exceeding high utlization
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/memory/test_memory.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f343a7790&gt;, show_cmd = 'show version'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_is_synchronized_on_[kg-topology-CloudEOSEdge1]" time="0.282"><failure message="AssertionError">self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f3438e160&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_ntp_is_synchronized_on_(self, dut, tests_definitions):
        """ Verify ntp is synchronzied
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/ntp/test_ntp.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34430280&gt;, show_cmd = 'show ntp status'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_associated_with_peers_on_[kg-topology-CloudEOSEdge1]" time="0.297"><failure message="AssertionError">self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f34279d60&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_ntp_associated_with_peers_on_(self, dut, tests_definitions):
        """ Verify ntp peers are correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/ntp/test_ntp.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f344167c0&gt;, show_cmd = 'show ntp associations'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_process_is_running_on_[kg-topology-CloudEOSEdge1]" time="0.278"><failure message="AssertionError">self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f343514c0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_process_is_running_on_(self, dut, tests_definitions):
        """ Verify ntp processes are running
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/ntp/test_ntp.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34508580&gt;, show_cmd = 'show processes'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_ntp_configuration_on_[kg-topology-CloudEOSEdge1]" time="0.298"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section ntp"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section ntp"], "format": "json"}, "id": "140115639903856"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section ntp"], "format": "json"}, "id": "140115639903856"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.129.78.225\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 163\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f3449b640&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_ntp_configuration_on_(self, dut, tests_definitions):
        """ Verifies NTP configuration matches the recommended practices
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
&gt;       tops.return_show_cmd("show running-config section ntp")

tests/ntp/test_ntp.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:723: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section ntp"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_servers_are_reachable_on_[kg-topology-CloudEOSEdge1]" time="0.329"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 169.254.169.123"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 169.254.169.123"], "format": "json"}, "id": "140115639903856"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 169.254.169.123"], "format": "json"}, "id": "140115639903856"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.129.78.225\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 152\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f343ab730&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_ntp_servers_are_reachable_on_(self, dut, tests_definitions):
        """ Verifies DNS servers are reachable via ping
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
        ntp_servers = tops.test_parameters["ntp_servers"]
        ntp_vrf = tops.test_parameters["ntp_vrf"]
    
        for ntp_server in ntp_servers:
            if ntp_vrf:
                show_cmd = f"ping vrf {ntp_vrf} ip {ntp_server}"
            else:
                show_cmd = f"ping {ntp_server}"
    
&gt;           tops.return_show_cmd(show_cmd)

tests/ntp/test_ntp.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:723: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 169.254.169.123"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.system.test_system.CrashTests" name="test_if_there_is_agents_have_crashed_on_[kg-topology-CloudEOSEdge1]" time="0.340"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show agent logs crash"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show agent logs crash"], "format": "json"}, "id": "140115639903856"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show agent logs crash"], "format": "json"}, "id": "140115639903856"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.129.78.225\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 153\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.129.78.225:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.129.78.225', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.system.test_system.CrashTests object at 0x7f6f342601f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_there_is_agents_have_crashed_on_(self, dut, tests_definitions):
        """ Verifies the agents logs crash is empty
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
&gt;       tops.return_show_cmd("show agent logs crash")

tests/system/test_system.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:723: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.129.78.225:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show agent logs crash"], "format": "json"}, "id": "140115639903856"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.system.test_system.SystemTests" name="test_if_eos_version_is_correct_on_[kg-topology-CloudEOSEdge1]" time="0.269"><failure message="AssertionError">self = &lt;vane.bin.tests.system.test_system.SystemTests object at 0x7f6f34251280&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_eos_version_is_correct_on_(self, dut, tests_definitions):
        """ Verifies EOS version running on the device
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/system/test_system.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34251610&gt;, show_cmd = 'show version'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.tacacs.test_tacacs.TacacsTests" name="test_if_tacacs_is_sending_messages_on_[kg-topology-CloudEOSEdge1]" time="0.262"><failure message="AssertionError">self = &lt;vane.bin.tests.tacacs.test_tacacs.TacacsTests object at 0x7f6f34251ac0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_tacacs_is_sending_messages_on_(self, dut, tests_definitions):
        """ Verify tacacs messages are sending correctly
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/tacacs/test_tacacs.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show tacacs'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.tacacs.test_tacacs.TacacsTests" name="test_if_tacacs_is_receiving_messages_on_[kg-topology-CloudEOSEdge1]" time="0.304"><failure message="AssertionError">self = &lt;vane.bin.tests.tacacs.test_tacacs.TacacsTests object at 0x7f6f342801f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_tacacs_is_receiving_messages_on_(self,
                                                      dut,
                                                      tests_definitions):
        """ Verify tacacs messages are received correctly
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/tacacs/test_tacacs.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show tacacs'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.users.test_users.UsersTests" name="test_if_usernames_are_configured_on_[kg-topology-CloudEOSEdge1]" time="0.309"><failure message="AssertionError">self = &lt;vane.bin.tests.users.test_users.UsersTests object at 0x7f6f34269a00&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_usernames_are_configured_on_(self, dut, tests_definitions):
        """ Verify username is set correctly
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/users/test_users.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34269c70&gt;, show_cmd = 'show running-config section username'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ztp.test_ztp.ZTPTests" name="test_if_zerotouch_is_disabled_on_[kg-topology-CloudEOSEdge1]" time="0.268"><failure message="AssertionError">self = &lt;vane.bin.tests.ztp.test_ztp.ZTPTests object at 0x7f6f340fe730&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_zerotouch_is_disabled_on_(self, dut, tests_definitions):
        """ Verify ztp is disabled
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/ztp/test_ztp.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f340fe580&gt;, show_cmd = 'show zerotouch'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ztp.test_ztp.ZTPTests" name="test_for_zerotouch_config_file_on_[kg-topology-CloudEOSEdge1]" time="0.261"><failure message="AssertionError">self = &lt;vane.bin.tests.ztp.test_ztp.ZTPTests object at 0x7f6f340d17c0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_for_zerotouch_config_file_on_(self, dut, tests_definitions):
        """ Verify zerotoucn-config file is on flash
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/ztp/test_ztp.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3433b730&gt;, show_cmd = 'dir flash:zerotouch-config'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.129.78.225:443//command-api)), 'name': 'kg-topology-...oudEOSEdge1', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.test_pytest.PyTestTests" name="test_assert_true[kg-topology-CloudEOSEdge2]" time="0.002" /><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_authentication_counters_are_incrementing_on_[kg-topology-CloudEOSEdge2]" time="0.001"><skipped type="pytest.skip" message="No AAA setup on DUTs">/project/vane/bin/tests/aaa/test_aaa.py:51: No AAA setup on DUTs</skipped></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_aaa_session_logging_is_working_on_[kg-topology-CloudEOSEdge2]" time="0.266"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f342e83a0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_aaa_session_logging_is_working_on_(self,
                                                   dut,
                                                   tests_definitions):
        """ Verify AAA session logging is working by identifying eapi connection
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show users detail'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_commands_authorization_methods_set_on_[kg-topology-CloudEOSEdge2]" time="0.281"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f342e5340&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authorization
    def test_if_commands_authorization_methods_set_on_(self,
                                                       dut,
                                                       tests_definitions):
        """ Verify AAA command authorization are method-lists set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        cmd_auth = test_parameters["cmd_auth"]
        expected_output = cmd_auth
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_exec_authorization_methods_set_on_[kg-topology-CloudEOSEdge2]" time="0.276"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f34376e20&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authorization
    def test_if_exec_authorization_methods_set_on_(self,
                                                   dut,
                                                   tests_definitions):
        """ Verify AAA exec authorization are method-lists set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        exec_auth = test_parameters["exec_auth"]
        expected_output = exec_auth
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_default_login_authentication_methods_set_on_[kg-topology-CloudEOSEdge2]" time="0.264"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f341e64c0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authentication
    def test_if_default_login_authentication_methods_set_on_(self,
                                                             dut,
                                                             tests_definitions):
        """ Verify AAA default login authentication are method-lists set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        login_auth = test_parameters["login_auth"]
        expected_output = login_auth
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_login_authentication_methods_set_on_[kg-topology-CloudEOSEdge2]" time="0.253"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f342e2880&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authentication
    def test_if_login_authentication_methods_set_on_(self,
                                                     dut,
                                                     tests_definitions):
        """ Verify AAA login authentication are method-lists set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        login_auth = test_parameters["login_auth"]
        expected_output = login_auth
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_dot1x_authentication_methods_set_on_[kg-topology-CloudEOSEdge2]" time="0.306"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f341067f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authentication
    def test_if_dot1x_authentication_methods_set_on_(self,
                                                     dut,
                                                     tests_definitions):
        """ Verify AAA dot1x authentication are method-lists set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        dot1x_auth = test_parameters["dot1x_auth"]
        expected_output = dot1x_auth
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_enable_authentication_methods_set_on_[kg-topology-CloudEOSEdge2]" time="0.283"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f341025e0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.authentication
    def test_if_enable_authentication_methods_set_on_(self,
                                                      dut,
                                                      tests_definitions):
        """ Verify AAA enable authentication method-lists are set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        enable_auth = test_parameters["enable_auth"]
        expected_output = enable_auth
    
        logging.info('TEST is enable authentication methods list set correct '
                     f'on |{dut_name}| ')
        logging.info('GIVEN enable authentication method list: '
                     f'|{enable_auth}|')
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_system_accounting_methods_set_on_[kg-topology-CloudEOSEdge2]" time="0.295"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f34385160&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.accounting
    def test_if_system_accounting_methods_set_on_(self,
                                                  dut,
                                                  tests_definitions):
        """ Verify AAA system accounting method-lists are set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        default_acct = test_parameters["default_acct"]
        console_acct = test_parameters["console_acct"]
        expected_output = [default_acct, console_acct]
    
        logging.info(f'TEST is system accounting methods list set correct '
                     f'on |{dut_name}| ')
        logging.info(f'GIVEN default system accounting method list: '
                     f'|{default_acct}| and console system accounting method'
                     f'list: |{console_acct}|')
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:455: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_exec_accounting_methods_set_on_[kg-topology-CloudEOSEdge2]" time="0.323"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f341928b0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.accounting
    def test_if_exec_accounting_methods_set_on_(self, dut, tests_definitions):
        """ Verify AAA exec accounting method-lists are set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        default_acct = test_parameters["default_acct"]
        console_acct = test_parameters["console_acct"]
        expected_output = [default_acct, console_acct]
    
        logging.info(f'TEST is exec accounting methods list set correct '
                     f'on |{dut_name}| ')
        logging.info(f'GIVEN exec system accounting method list: '
                     f'|{default_acct}| and exec system accounting method'
                     f'list: |{console_acct}|')
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:503: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_priviledge_accounting_methods_set_on_[kg-topology-CloudEOSEdge2]" time="0.300"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f340b77f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.accounting
    def test_if_priviledge_accounting_methods_set_on_(self,
                                                      dut,
                                                      tests_definitions):
        """ Verify AAA priviledge accounting method-lists are set correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        default_acct = test_parameters["default_acct"]
        console_acct = test_parameters["console_acct"]
        expected_output = [default_acct, console_acct]
    
        logging.info(f'TEST is priviledge accounting methods list set correct '
                     f'on |{dut_name}| ')
        logging.info(f'GIVEN priviledge system accounting method list: '
                     f'|{default_acct}| and priviledge system accounting '
                     f'method list: |{console_acct}|')
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.aaa.test_aaa.AAATests" name="test_if_dot1x_accounting_methods_set_on_[kg-topology-CloudEOSEdge2]" time="0.350"><failure message="AssertionError">self = &lt;vane.bin.tests.aaa.test_aaa.AAATests object at 0x7f6f340cd760&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    @pytest.mark.accounting
    def test_if_dot1x_accounting_methods_set_on_(self, dut, tests_definitions):
        """ Verify AAA dot1x accounting method-lists are set correct
    
             Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
        default_acct = test_parameters["default_acct"]
        console_acct = test_parameters["console_acct"]
        expected_output = [default_acct, console_acct]
    
        logging.info(f'TEST is dot1x accounting methods list set correct on '
                     f'|{dut_name}|')
        logging.info(f'GIVEN dot1x system accounting method list: '
                     f'|{default_acct}| and dot1x system accounting method'
                     f'list: |{console_acct}|')
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/aaa/test_aaa.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show aaa methods all'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_is_running_on_[kg-topology-CloudEOSEdge2]" time="0.377"><failure message="AssertionError">self = &lt;vane.bin.tests.api.test_api.APITests object at 0x7f6f343783a0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_management_https_api_server_is_running_on_(self,
                                                           dut,
                                                           tests_definitions):
      """ Verify management api https server is running
           Args:
            dut (dict): Encapsulates dut details including name, connection
            tests_definitions (dict): Test parameters
      """
    
&gt;     tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/api/test_api.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f343d6820&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_port_is_correct_on_[kg-topology-CloudEOSEdge2]" time="0.358"><failure message="AssertionError">self = &lt;vane.bin.tests.api.test_api.APITests object at 0x7f6f34368100&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_management_https_api_server_port_is_correct_on_(self,
                                                                dut,
                                                                tests_definitions):
      """ Verify https server is enabled on port 443
           Args:
            dut (dict): Encapsulates dut details including name, connection
            tests_definitions (dict): Test parameters
      """
    
&gt;     tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/api/test_api.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f343dc8e0&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.api.test_api.APITests" name="test_if_management_https_api_server_is_enabled_on_[kg-topology-CloudEOSEdge2]" time="0.395"><failure message="AssertionError">self = &lt;vane.bin.tests.api.test_api.APITests object at 0x7f6f340ab9d0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_management_https_api_server_is_enabled_on_(self,
                                                           dut,
                                                           tests_definitions):
      """ Verify management api https server is enabled
           Args:
            dut (dict): Encapsulates dut details including name, connection
            tests_definitions (dict): Test parameters
      """
    
&gt;     tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/api/test_api.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f343d56d0&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.api.test_api.APITests" name="test_if_management_http_api_server_is_running_on_[kg-topology-CloudEOSEdge2]" time="0.561"><failure message="AssertionError">self = &lt;vane.bin.tests.api.test_api.APITests object at 0x7f6f34068fd0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_management_http_api_server_is_running_on_(self,
                                                          dut,
                                                          tests_definitions):
      """ Verify management api http server is not running
           Args:
            dut (dict): Encapsulates dut details including name, connection
            tests_definitions (dict): Test parameters
      """
    
&gt;     tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/api/test_api.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34068790&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.api.test_api.APITests" name="test_if_management_local_http_api_server_is_running_on_[kg-topology-CloudEOSEdge2]" time="0.749"><failure message="AssertionError">self = &lt;vane.bin.tests.api.test_api.APITests object at 0x7f6f3435e100&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_management_local_http_api_server_is_running_on_(self,
                                                                dut,
                                                                tests_definitions):
      """ Verify management api local httpserver is not running
           Args:
            dut (dict): Encapsulates dut details including name, connection
            tests_definitions (dict): Test parameters
      """
    
&gt;     tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/api/test_api.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34193dc0&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_1_sec_cpu_utlization_on_[kg-topology-CloudEOSEdge2]" time="0.415"><failure message="AssertionError">self = &lt;vane.bin.tests.cpu.test_cpu.CPUTests object at 0x7f6f3409eee0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_1_sec_cpu_utlization_on_(self, dut, tests_definitions):
        """ Verify 1 second CPU % is under specificied value
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/cpu/test_cpu.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3435ef40&gt;, show_cmd = 'show processes'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_1_min_cpu_utlization_on_[kg-topology-CloudEOSEdge2]" time="0.720"><failure message="AssertionError">self = &lt;vane.bin.tests.cpu.test_cpu.CPUTests object at 0x7f6f343ea700&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_1_min_cpu_utlization_on_(self, dut, tests_definitions):
        """ Verify 1 minute CPU % is under specificied value
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/cpu/test_cpu.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f343ea5e0&gt;, show_cmd = 'show processes'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.cpu.test_cpu.CPUTests" name="test_5_min_cpu_utlization_on_[kg-topology-CloudEOSEdge2]" time="0.363"><failure message="AssertionError">self = &lt;vane.bin.tests.cpu.test_cpu.CPUTests object at 0x7f6f341c1d30&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_5_min_cpu_utlization_on_(self, dut, tests_definitions):
        """ Verify 5 minute CPU % is under specificied value
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/cpu/test_cpu.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f342074c0&gt;, show_cmd = 'show processes'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.daemon.test_daemon.DaemonTests" name="test_if_daemons_are_running_on_[kg-topology-CloudEOSEdge2]" time="0.382"><failure message="AssertionError">self = &lt;vane.bin.tests.daemon.test_daemon.DaemonTests object at 0x7f6f341b6e80&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_daemons_are_running_on_(self, dut, tests_definitions):
        """ Verify a list of daemons are running on DUT
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/daemon/test_daemon.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f341b61f0&gt;, show_cmd = 'show daemon'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.daemon.test_daemon.DaemonTests" name="test_if_daemons_are_enabled_on_[kg-topology-CloudEOSEdge2]" time="0.333"><failure message="AssertionError">self = &lt;vane.bin.tests.daemon.test_daemon.DaemonTests object at 0x7f6f3419dcd0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_daemons_are_enabled_on_(self, dut, tests_definitions):
        """ Verify a list of daemons are enabled on DUT
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/daemon/test_daemon.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34207f10&gt;, show_cmd = 'show daemon'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.dns.test_dns.DNSTests" name="test_if_dns_resolves_on_[kg-topology-CloudEOSEdge2]" time="0.333"><failure message="AssertionError">self = &lt;vane.bin.tests.dns.test_dns.DNSTests object at 0x7f6f341b6490&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_dns_resolves_on_(self, dut, tests_definitions):
        """ Verify DNS is running by performing pings and verifying name resolution
    
             Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/dns/test_dns.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34152640&gt;, show_cmd = 'show management api http-commands'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.dns.test_dns.DNSTests" name="test_if_dns_servers_are_reachable_on_[kg-topology-CloudEOSEdge2]" time="0.380"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 11.201.12.2"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 11.201.12.2"], "format": "json"}, "id": "140115639902320"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 11.201.12.2"], "format": "json"}, "id": "140115639902320"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.137.2.78\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 148\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.dns.test_dns.DNSTests object at 0x7f6f341771f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_dns_servers_are_reachable_on_(self, dut, tests_definitions):
        """ Verifies DNS servers are reachable via ping
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
        dns_servers = tops.test_parameters["dns_servers"]
        dns_vrf = tops.test_parameters["dns_vrf"]
    
        for dns_server in dns_servers:
            if dns_vrf:
                show_cmd = f"ping vrf {dns_vrf} ip {dns_server}"
            else:
                show_cmd = f"ping {dns_server}"
    
&gt;           tops.return_show_cmd(show_cmd)

tests/dns/test_dns.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:723: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 11.201.12.2"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.dns.test_dns.DNSTests" name="test_dns_configuration_on_[kg-topology-CloudEOSEdge2]" time="0.358"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section name-server"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section name-server"], "format": "json"}, "id": "140115639902320"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section name-server"], "format": "json"}, "id": "140115639902320"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.137.2.78\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 171\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.dns.test_dns.DNSTests object at 0x7f6f340c88e0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_dns_configuration_on_(self, dut, tests_definitions):
        """ Verifies DNS configuration matches the recommended practices
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
&gt;       tops.return_show_cmd("show running-config section name-server")

tests/dns/test_dns.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:723: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section name-server"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_temp_is_in_spec_on_[kg-topology-CloudEOSEdge2]" time="0.356"><failure message="KeyError: 'show version'">self = &lt;vane.bin.tests.environment.test_environment.EnvironmentTests object at 0x7f6f34087cd0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_system_environment_temp_is_in_spec_on_(self,
                                                        dut,
                                                        tests_definitions):
        """ Verify system temperature environmentals are functional within spec
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
&gt;       if not tests_tools.verify_veos(dut):

tests/environment/test_environment.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_veos(dut):
        """ Verify DUT is a VEOS instance
    
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        show_cmd = "show version"
    
        veos_bool = False
&gt;       veos = dut["output"][show_cmd]['json']['modelName']
E       KeyError: 'show version'

tests_tools.py:456: KeyError</failure></testcase><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_sensors_temp_is_in_spec_on_[kg-topology-CloudEOSEdge2]" time="0.367"><failure message="KeyError: 'show version'">self = &lt;vane.bin.tests.environment.test_environment.EnvironmentTests object at 0x7f6f27e250a0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_sensors_temp_is_in_spec_on_(self, dut, tests_definitions):
        """ Verify system temperature sensors environmentals are functional within spec
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
&gt;       if not tests_tools.verify_veos(dut):

tests/environment/test_environment.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_veos(dut):
        """ Verify DUT is a VEOS instance
    
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        show_cmd = "show version"
    
        veos_bool = False
&gt;       veos = dut["output"][show_cmd]['json']['modelName']
E       KeyError: 'show version'

tests_tools.py:456: KeyError</failure></testcase><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_power_are_in_spec_on_[kg-topology-CloudEOSEdge2]" time="0.347"><failure message="KeyError: 'show version'">self = &lt;vane.bin.tests.environment.test_environment.EnvironmentTests object at 0x7f6f27e02070&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_system_environment_power_are_in_spec_on_(self,
                                                         dut,
                                                         tests_definitions):
        """ Verify system power environmentals are functional within spec
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
&gt;       if not tests_tools.verify_veos(dut):

tests/environment/test_environment.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_veos(dut):
        """ Verify DUT is a VEOS instance
    
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        show_cmd = "show version"
    
        veos_bool = False
&gt;       veos = dut["output"][show_cmd]['json']['modelName']
E       KeyError: 'show version'

tests_tools.py:456: KeyError</failure></testcase><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_system_environment_cooling_is_in_spec_on_[kg-topology-CloudEOSEdge2]" time="0.329"><failure message="AssertionError">self = &lt;vane.bin.tests.environment.test_environment.EnvironmentTests object at 0x7f6f27f7f0a0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_system_environment_cooling_is_in_spec_on_(self,
                                                          dut,
                                                          tests_definitions):
        """ Verify system cooling environmentals are functional within spec
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/environment/test_environment.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27f60670&gt;, show_cmd = 'show system environment cooling'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.environment.test_environment.EnvironmentTests" name="test_if_fan_status_is_in_spec_on_[kg-topology-CloudEOSEdge2]" time="0.343"><failure message="AssertionError">self = &lt;vane.bin.tests.environment.test_environment.EnvironmentTests object at 0x7f6f34178d30&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...utput': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling', ...}]}, ...]}

    def test_if_fan_status_is_in_spec_on_(self, dut, tests_definitions):
        """ Verify system cooling environmentals are functional within spec
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/environment/test_environment.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27f60820&gt;, show_cmd = 'show system environment cooling'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.extension.test_extension.ExtensionsTests" name="test_if_extensions_are_installed_on_[kg-topology-CloudEOSEdge2]" time="0.375"><failure message="AssertionError">self = &lt;vane.bin.tests.extension.test_extension.ExtensionsTests object at 0x7f6f34178a90&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_extensions_are_installed_on_(self, dut, tests_definitions):
        """ Verify a list of extension are installed on a DUT
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/extension/test_extension.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27f60a30&gt;, show_cmd = 'show extensions'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.extension.test_extension.ExtensionsTests" name="test_if_extensions_are_erroring_on_[kg-topology-CloudEOSEdge2]" time="0.338"><failure message="AssertionError">self = &lt;vane.bin.tests.extension.test_extension.ExtensionsTests object at 0x7f6f27e1db50&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_extensions_are_erroring_on_(self, dut, tests_definitions):
        """ Verify a list of extension are not erroring on a DUT
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/extension/test_extension.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27f62220&gt;, show_cmd = 'show extensions'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.filesystem.test_filesystem.FileSystemTests" name="test_if_files_on_[kg-topology-CloudEOSEdge2]" time="0.370"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show file information flash:startup-config"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show file information flash:startup-config"], "format": "json"}, "id": "140115639902320"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show file information flash:startup-config"], "format": "json"}, "id": "140115639902320"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.137.2.78\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 174\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.filesystem.test_filesystem.FileSystemTests object at 0x7f6f27e32d90&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_files_on_(self, dut, tests_definitions):
        """ Verify filesystem is correct and expected files are present
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
    
        files = tops.test_parameters["files"]
    
        for file_name in files:
            show_cmd = f"show file information {file_name}"
&gt;           show_output, show_cmd_txt = tests_tools.return_show_cmd(show_cmd,
                                                                    dut,
                                                                    tops.test_case,
                                                                    LOG_FILE)

tests/filesystem/test_filesystem.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:290: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show file information flash:startup-config"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.host.test_host.HostTests" name="test_if_hostname_is_correcet_on_[kg-topology-CloudEOSEdge2]" time="0.347"><failure message="AssertionError">self = &lt;vane.bin.tests.host.test_host.HostTests object at 0x7f6f27f64e80&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_hostname_is_correcet_on_(self, dut, tests_definitions):
        """ Verify hostname is set on device is correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/host/test_host.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27f41070&gt;, show_cmd = 'show hostname'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceStatusTests" name="test_if_intf_protocol_status_is_connected_on_[kg-topology-CloudEOSEdge2]" time="0.327"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceStatusTests object at 0x7f6f27fd6bb0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_protocol_status_is_connected_on_(self,
                                                      dut,
                                                      tests_definitions):
        """ Verify the interfaces of interest protocol statuses are up
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27f28430&gt;, show_cmd = 'show interfaces status'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceStatusTests" name="test_if_intf_link_status_is_connected_on_[kg-topology-CloudEOSEdge2]" time="0.324"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceStatusTests object at 0x7f6f27f266a0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_link_status_is_connected_on_(self,
                                                  dut,
                                                  tests_definitions):
        """ Verify the interfaces of interest link statuses are up
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27f28820&gt;, show_cmd = 'show interfaces status'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfacePhyTests" name="test_if_intf_phy_status_connected_on_[kg-topology-CloudEOSEdge2]" time="0.365"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfacePhyTests object at 0x7f6f27f26070&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_phy_status_connected_on_(self,
                                              dut,
                                              tests_definitions):
        """ Verify the interfaces of interest physical state is link up
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27f1e280&gt;, show_cmd = 'show interfaces phy detail'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceCountersTests" name="test_if_interface_errors_on_[kg-topology-CloudEOSEdge2]" time="0.315"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceCountersTests object at 0x7f6f27f1e1f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_interface_errors_on_(self, dut, tests_definitions):
        """  Verify the interfaces of interest have no inDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:622: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34150ca0&gt;, show_cmd = 'show interfaces'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceCountersTests" name="test_interface_utilization_on_[kg-topology-CloudEOSEdge2]" time="0.320"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceCountersTests object at 0x7f6f341250d0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_interface_utilization_on_(self, dut, tests_definitions):
        """  Verify the interfaces of interest have no inDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27f79ca0&gt;, show_cmd = 'show interfaces'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceDiscardTests" name="test_if_intf_out_counters_are_discarding_on_[kg-topology-CloudEOSEdge2]" time="0.295"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceDiscardTests object at 0x7f6f27ff18e0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_out_counters_are_discarding_on_(self,
                                                     dut,
                                                     tests_definitions):
        """  Verify the interfaces of interest have no outDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:492: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34031400&gt;, show_cmd = 'show interfaces counters discards'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceDiscardTests" name="test_if_intf_in_counters_are_discarding_on_[kg-topology-CloudEOSEdge2]" time="0.281"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceDiscardTests object at 0x7f6f34031f70&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_in_counters_are_discarding_on_(self,
                                                    dut,
                                                    tests_definitions):
        """  Verify the interfaces of interest have no inDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:532: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3414ffd0&gt;, show_cmd = 'show interfaces counters discards'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.interface.test_interface.InterfaceMtuTests" name="test_if_intf_mtu_is_correct_on_[kg-topology-CloudEOSEdge2]" time="0.279"><failure message="AssertionError">self = &lt;vane.bin.tests.interface.test_interface.InterfaceMtuTests object at 0x7f6f34031130&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_intf_mtu_is_correct_on_(self, dut, tests_definitions):
        """  Verify the interfaces of interest have no inDiscards
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/interface/test_interface.py:577: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3414f640&gt;, show_cmd = 'show interfaces'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpTests" name="test_if_lldp_rx_is_enabled_on_[kg-topology-CloudEOSEdge2]" time="0.298"><failure message="AssertionError">self = &lt;vane.bin.tests.lldp.test_lldp.LldpTests object at 0x7f6f3414f430&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_rx_is_enabled_on_(self, dut, tests_definitions):
        """  Verify LLDP receive is enabled on interesting interfaces
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/lldp/test_lldp.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34044460&gt;, show_cmd = 'show lldp'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpTests" name="test_if_lldp_tx_is_enabled_on_[kg-topology-CloudEOSEdge2]" time="0.286"><failure message="AssertionError">self = &lt;vane.bin.tests.lldp.test_lldp.LldpTests object at 0x7f6f342c6ac0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_tx_is_enabled_on_(self, dut, tests_definitions):
        """  Verify LLDP transmit is enabled on interesting interfaces
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/lldp/test_lldp.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3414af10&gt;, show_cmd = 'show lldp'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_system_name_is_correct_on_[kg-topology-CloudEOSEdge2]" time="0.309"><failure message="AssertionError">self = &lt;vane.bin.tests.lldp.test_lldp.LldpLocalInfoTests object at 0x7f6f27fed970&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_system_name_is_correct_on_(self, dut, tests_definitions):
        """  Verify show lldp local-info hostname is the system's name
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/lldp/test_lldp.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3413c3d0&gt;, show_cmd = 'show lldp local-info'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_max_frame_size_is_correct_on_[kg-topology-CloudEOSEdge2]" time="0.279"><failure message="AssertionError">self = &lt;vane.bin.tests.lldp.test_lldp.LldpLocalInfoTests object at 0x7f6f3413a220&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_max_frame_size_is_correct_on_(self, dut, tests_definitions):
        """  Verify show lldp local-info maxFrameSize is correct
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/lldp/test_lldp.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f3413a2b0&gt;, show_cmd = 'show lldp local-info'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.lldp.test_lldp.LldpLocalInfoTests" name="test_if_lldp_interface_id_is_correct_on_[kg-topology-CloudEOSEdge2]" time="0.274"><failure message="AssertionError">self = &lt;vane.bin.tests.lldp.test_lldp.LldpLocalInfoTests object at 0x7f6f27f21790&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_lldp_interface_id_is_correct_on_(self, dut, tests_definitions):
        """  Verify show lldp local-info interfaceIdType is correct
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/lldp/test_lldp.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34149430&gt;, show_cmd = 'show lldp local-info'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.log.test_logging.LoggingTests" name="test_if_log_messages_appear_on_[kg-topology-CloudEOSEdge2]" time="0.284"><failure message="AssertionError">self = &lt;vane.bin.tests.log.test_logging.LoggingTests object at 0x7f6f27ecfa60&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_log_messages_appear_on_(self, dut, tests_definitions):
        """ Verify local log messages
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/log/test_logging.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27ffa460&gt;, show_cmd = 'show logging'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.memory.test_memory.MemoryTests" name="test_memory_utilization_on_[kg-topology-CloudEOSEdge2]" time="0.289"><failure message="AssertionError">self = &lt;vane.bin.tests.memory.test_memory.MemoryTests object at 0x7f6f27ee23d0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_memory_utilization_on_(self, dut, tests_definitions):
        """ Verify memory is not exceeding high utlization
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/memory/test_memory.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27fc3880&gt;, show_cmd = 'show version'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_is_synchronized_on_[kg-topology-CloudEOSEdge2]" time="0.281"><failure message="AssertionError">self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f3414f340&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_ntp_is_synchronized_on_(self, dut, tests_definitions):
        """ Verify ntp is synchronzied
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/ntp/test_ntp.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f341690a0&gt;, show_cmd = 'show ntp status'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_associated_with_peers_on_[kg-topology-CloudEOSEdge2]" time="0.302"><failure message="AssertionError">self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f27fc32e0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_ntp_associated_with_peers_on_(self, dut, tests_definitions):
        """ Verify ntp peers are correct
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/ntp/test_ntp.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34145e80&gt;, show_cmd = 'show ntp associations'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_process_is_running_on_[kg-topology-CloudEOSEdge2]" time="0.328"><failure message="AssertionError">self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f27fcde50&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_process_is_running_on_(self, dut, tests_definitions):
        """ Verify ntp processes are running
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/ntp/test_ntp.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f341459d0&gt;, show_cmd = 'show processes'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_ntp_configuration_on_[kg-topology-CloudEOSEdge2]" time="0.309"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section ntp"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section ntp"], "format": "json"}, "id": "140115639902320"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section ntp"], "format": "json"}, "id": "140115639902320"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.137.2.78\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 163\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f34137790&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_ntp_configuration_on_(self, dut, tests_definitions):
        """ Verifies NTP configuration matches the recommended practices
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
&gt;       tops.return_show_cmd("show running-config section ntp")

tests/ntp/test_ntp.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:723: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show running-config section ntp"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.ntp.test_ntp.NTPTests" name="test_if_ntp_servers_are_reachable_on_[kg-topology-CloudEOSEdge2]" time="0.335"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 169.254.169.123"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 169.254.169.123"], "format": "json"}, "id": "140115639902320"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 169.254.169.123"], "format": "json"}, "id": "140115639902320"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.137.2.78\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 152\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.ntp.test_ntp.NTPTests object at 0x7f6f342a42b0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_ntp_servers_are_reachable_on_(self, dut, tests_definitions):
        """ Verifies DNS servers are reachable via ping
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
        ntp_servers = tops.test_parameters["ntp_servers"]
        ntp_vrf = tops.test_parameters["ntp_vrf"]
    
        for ntp_server in ntp_servers:
            if ntp_vrf:
                show_cmd = f"ping vrf {ntp_vrf} ip {ntp_server}"
            else:
                show_cmd = f"ping {ntp_server}"
    
&gt;           tops.return_show_cmd(show_cmd)

tests/ntp/test_ntp.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:723: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "ping 169.254.169.123"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.system.test_system.CrashTests" name="test_if_there_is_agents_have_crashed_on_[kg-topology-CloudEOSEdge2]" time="0.315"><failure message="pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused">self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show agent logs crash"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
&gt;           self.transport.endheaders(message_body=data)

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show agent logs crash"], "format": "json"}, "id": "140115639902320"}'

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/local/lib/python3.8/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
message_body = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show agent logs crash"], "format": "json"}, "id": "140115639902320"}'
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

/usr/local/lib/python3.8/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api
data = b'POST /command-api HTTP/1.1\r\nHost: 3.137.2.78\r\nAccept-Encoding: identity\r\nContent-type: application/json-rpc\r\nContent-length: 153\r\nAuthorization: Basic a2dyb3ppczphcmlzdGExMjM=\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/local/lib/python3.8/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        "Connect to a host on a given (SSL) port."
    
&gt;       super().connect()

/usr/local/lib/python3.8/http/client.py:1417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = https://3.137.2.78:443//command-api

    def connect(self):
        """Connect to the host and port specified in __init__."""
&gt;       self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)

/usr/local/lib/python3.8/http/client.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                # Break explicitly a reference cycle
                err = None
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
            try:
&gt;               raise err

/usr/local/lib/python3.8/socket.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('3.137.2.78', 443), timeout = 60, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;vane.bin.tests.system.test_system.CrashTests object at 0x7f6f27ec9ee0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_there_is_agents_have_crashed_on_(self, dut, tests_definitions):
        """ Verifies the agents logs crash is empty
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
        """
    
        tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)
&gt;       tops.return_show_cmd("show agent logs crash")

tests/system/test_system.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:723: in return_show_cmd
    show_output = conn.enable(show_cmd)
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:684: in enable
    resp = self.run_commands(command, encoding, send_enable,
/usr/local/lib/python3.8/site-packages/pyeapi/client.py:743: in run_commands
    response = self._connection.execute(commands, encoding, **kwargs)
/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:550: in execute
    response = self.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = EapiConnection(transport=https://3.137.2.78:443//command-api)
data = b'{"jsonrpc": "2.0", "method": "runCmds", "params": {"version": 1, "cmds": ["enable", "show agent logs crash"], "format": "json"}, "id": "140115639902320"}'

    def send(self, data):
        """Sends the eAPI request to the destination node
    
        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.
    
        eAPI Response - success
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            &lt;message&gt;
                        ]
                    },
                ],
                "id": &lt;reqid&gt;
            }
    
        eAPI Response - failure
    
        .. code-block:: json
    
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": &lt;int&gt;,
                    "message": &lt;string&gt;
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                &lt;message&gt;
                            ]
                        }
                    ]
                }
                "id": &lt;reqid&gt;
            }
    
        Args:
            data (string): The data to be included in the body of the eAPI
                request object
    
        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object
    
        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            _LOGGER.debug('Request content: {}'.format(data))
            # debug('eapi_request: %s' % data)
    
            self.transport.putrequest('POST', '/command-api')
    
            self.transport.putheader('Content-type', 'application/json-rpc')
            self.transport.putheader('Content-length', '%d' % len(data))
    
            if self._auth:
                self.transport.putheader('Authorization',
                                         'Basic %s' % self._auth)
    
            if int(sys.version[0]) &gt; 2:
                # For Python 3.x compatibility
                data = data.encode()
    
            self.transport.endheaders(message_body=data)
    
            try:  # Python 2.7: use buffering of HTTP responses
                response = self.transport.getresponse(buffering=True)
            except TypeError:  # Python 2.6: older, and 3.x on
                response = self.transport.getresponse()
    
            response_content = response.read()
            _LOGGER.debug('Response: status:{status}, reason:{reason}'.format(
                          status=response.status,
                          reason=response.reason))
            _LOGGER.debug('Response content: {}'.format(response_content))
    
            if response.status == 401:
                raise ConnectionError(str(self), '%s. %s' % (response.reason,
                                                             response_content))
    
            # Work around for Python 2.7/3.x compatibility
            if not type(response_content) == str:
                # For Python 3.x - decode bytes into string
                response_content = response_content.decode()
            decoded = json.loads(response_content)
            _LOGGER.debug('eapi_response: %s' % decoded)
    
            if 'error' in decoded:
                (code, msg, err, out) = self._parse_error_message(decoded)
                pattern = "unexpected keyword argument '(.*)'"
                match = re.search(pattern, msg)
                if match:
                    auto_msg = ('%s parameter is not supported in this'
                                ' version of EOS.' % match.group(1))
                    _LOGGER.error(auto_msg)
                    msg = msg + '. ' + auto_msg
                raise CommandError(code, msg, command_error=err, output=out)
    
            return decoded
    
        # socket.error is deprecated in python 3 and replaced with OSError.
        except (socket.error, OSError) as exc:
            _LOGGER.exception(exc)
            self.socket_error = exc
            self.error = exc
            error_msg = 'Socket error during eAPI connection: %s' % str(exc)
&gt;           raise ConnectionError(str(self), error_msg)
E           pyeapi.eapilib.ConnectionError: Socket error during eAPI connection: [Errno 111] Connection refused

/usr/local/lib/python3.8/site-packages/pyeapi/eapilib.py:479: ConnectionError</failure></testcase><testcase classname="tests.system.test_system.SystemTests" name="test_if_eos_version_is_correct_on_[kg-topology-CloudEOSEdge2]" time="0.282"><failure message="AssertionError">self = &lt;vane.bin.tests.system.test_system.SystemTests object at 0x7f6f3402c820&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_eos_version_is_correct_on_(self, dut, tests_definitions):
        """ Verifies EOS version running on the device
    
            Args:
                dut (dict): Encapsulates dut details including name, connection
                tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/system/test_system.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f34017df0&gt;, show_cmd = 'show version'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.tacacs.test_tacacs.TacacsTests" name="test_if_tacacs_is_sending_messages_on_[kg-topology-CloudEOSEdge2]" time="0.289"><failure message="AssertionError">self = &lt;vane.bin.tests.tacacs.test_tacacs.TacacsTests object at 0x7f6f27da3ca0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_tacacs_is_sending_messages_on_(self, dut, tests_definitions):
        """ Verify tacacs messages are sending correctly
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/tacacs/test_tacacs.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show tacacs'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.tacacs.test_tacacs.TacacsTests" name="test_if_tacacs_is_receiving_messages_on_[kg-topology-CloudEOSEdge2]" time="0.286"><failure message="AssertionError">self = &lt;vane.bin.tests.tacacs.test_tacacs.TacacsTests object at 0x7f6f34013070&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_tacacs_is_receiving_messages_on_(self,
                                                      dut,
                                                      tests_definitions):
        """ Verify tacacs messages are received correctly
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
        test_case = inspect.currentframe().f_code.co_name
        test_parameters = tests_tools.get_parameters(tests_definitions,
                                                     TEST_SUITE,
                                                     test_case)
    
        expected_output = test_parameters["expected_output"]
        dut_name = dut['name']
    
        show_cmd = test_parameters["show_cmd"]
&gt;       tests_tools.verify_show_cmd(show_cmd, dut)

tests/tacacs/test_tacacs.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

show_cmd = 'show tacacs'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def verify_show_cmd(show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:419: AssertionError</failure></testcase><testcase classname="tests.users.test_users.UsersTests" name="test_if_usernames_are_configured_on_[kg-topology-CloudEOSEdge2]" time="0.280"><failure message="AssertionError">self = &lt;vane.bin.tests.users.test_users.UsersTests object at 0x7f6f27e8c4f0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_usernames_are_configured_on_(self, dut, tests_definitions):
        """ Verify username is set correctly
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/users/test_users.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27ebcbb0&gt;, show_cmd = 'show running-config section username'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ztp.test_ztp.ZTPTests" name="test_if_zerotouch_is_disabled_on_[kg-topology-CloudEOSEdge2]" time="0.284"><failure message="AssertionError">self = &lt;vane.bin.tests.ztp.test_ztp.ZTPTests object at 0x7f6f27e8f100&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_if_zerotouch_is_disabled_on_(self, dut, tests_definitions):
        """ Verify ztp is disabled
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/ztp/test_ztp.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27ebc340&gt;, show_cmd = 'show zerotouch'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase><testcase classname="tests.ztp.test_ztp.ZTPTests" name="test_for_zerotouch_config_file_on_[kg-topology-CloudEOSEdge2]" time="0.303"><failure message="AssertionError">self = &lt;vane.bin.tests.ztp.test_ztp.ZTPTests object at 0x7f6f27ebccd0&gt;
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}
tests_definitions = {'test_suites': [{'name': 'test_aaa.py', 'testcases': [{'comment': None, 'description': 'Verify AAA counters are worki...ted_output': 'ok', 'name': 'test_if_fan_status_is_in_spec_on_', 'show_cmd': 'show system environment cooling'}]}, ...]}

    def test_for_zerotouch_config_file_on_(self, dut, tests_definitions):
        """ Verify zerotoucn-config file is on flash
    
            Args:
              dut (dict): Encapsulates dut details including name, connection
              tests_definitions (dict): Test parameters
        """
    
&gt;       tops = tests_tools.TestOps(tests_definitions, TEST_SUITE, dut)

tests/ztp/test_ztp.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests_tools.py:619: in __init__
    self._verify_show_cmd(self.show_cmd, dut)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;tests_tools.TestOps object at 0x7f6f27dacf70&gt;, show_cmd = 'dir flash:zerotouch-config'
dut = {'connection': Node(connection=EapiConnection(transport=https://3.137.2.78:443//command-api)), 'name': 'kg-topology-Cl...oudEOSEdge2', 'interface_name': 'Ethernet2', 'media_type': '', 'z_hostname': 'leaf01', ...}], 'show aaa counters': {}}}

    def _verify_show_cmd(self, show_cmd, dut):
        """ Verify if show command was successfully executed on dut
    
            show_cmd (str): show command
            dut (dict): data structure of dut parameters
        """
    
        dut_name = dut["name"]
        logging.info(f'Verify if show command |{show_cmd}| was successfully '
                     f'executed on {dut_name} dut')
    
        if show_cmd in dut["output"]:
            logging.info(f'Verified output for show command |{show_cmd}| on '
                         f'{dut_name}')
        else:
            logging.critical(f'Show command |{show_cmd}| not executed on '
                             f'{dut_name}')
&gt;           assert False
E           AssertionError

tests_tools.py:646: AssertionError</failure></testcase></testsuite></testsuites>