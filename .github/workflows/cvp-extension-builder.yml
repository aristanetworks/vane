name: cvp-extension-builder
run-name: Build CVP extension RPM package

# Build the CVP extension RPM package when a pull request is merged to main
# and save the RPM package in the artifacts of the workflow

on:
  # This is the default trigger, to run when a pull request on the 'main' branch is closed
  pull_request:
    branches:
      - main
    types:
      - closed

  # For testing, put the name of the testing branch here, and remove branch names afterwards
  push:
    branches:
      - example-rpm-package-testing-branch

  # Trigger a build manually from the browser interface
  workflow_dispatch:

# Variables
env:
  CVP_BUILD_IMAGE: ghcr.io/aristanetworks/vane-cvp-build:latest
  CVP_IMAGE: vane-cvp
  CVP_IMAGE_FILE: vane-cvp.tar.gz

# Job definitions
jobs:

  # Create the container we use to build the RPM
  #   This is a Centos container to match the CVP environment
  create_centos_build_container:

    runs-on: ubuntu-latest
    steps:
      - name: Check out the repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build the Centos container for creating the RPM images and push to GitHub container registry
        run: |
          docker build -t $CVP_BUILD_IMAGE -f Dockerfile.build-CVP . --build-arg UID=$(id -u) --build-arg GID=$(id -g)
          docker push $CVP_BUILD_IMAGE

  # Create the container that will be running in the CVP environment
  #   This is a minimal container with Vane and its requirements installed
  create_cvp_container:

    runs-on: ubuntu-latest
    steps:
      - name: Check out the repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Build the CVP Vane container and save it as a tar.gz file
        run: |
          docker build -t $CVP_IMAGE -f Dockerfile.CVP . --network=host
          docker save $CVP_IMAGE | gzip > $CVP_IMAGE_FILE

      - name: Upload the CVP Vane container tar.gz artifact for use in the next job
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.CVP_IMAGE_FILE }}
          path: ${{ env.CVP_IMAGE_FILE }}
          retention-days: 2

  # Create the RPM package and upload the package as an artifact
  package_cvp_container:

    # This job depends on the previous two containers being built
    needs: [create_centos_build_container, create_cvp_container]

    runs-on: ubuntu-latest
    container:
      # Use the previously built vane-cvp-build container
      # We can't use the CVP_BUILD_IMAGE variable here, because the context is not
      # available in the "job" scope
      image: ghcr.io/aristanetworks/vane-cvp-build:latest

    steps:
      - name: Check out the repository
        uses: actions/checkout@v4
        # with:
        #   fetch-depth: 0

      - name: Download the CVP Vane image file artifact we created in the previous job
        uses: actions/download-artifact@v3
        with:
          name: ${{ env.CVP_IMAGE_FILE }}

      - name: Build the CVP rpm package
        run: |
          ls -la
          make rpm-cvp

      # - name: Copy the installation scripts into the rpms directory for packaging
      #   run: |
      #     cp resources/vane-cvp-*.sh rpms/
      #     chmod +x rpms/vane-cvp-*.sh
      #     cd rpms
      #     tar cvzf vane-cvp-rpm.tar.gz *.rpm vane-cvp-*.sh
      #
      # - name: Save the rpm package as an artifact
      #   uses: actions/upload-artifact@v3
      #   with:
      #     name: vane-cvp-rpm
      #     path: rpms/vane-cvp-rpm.tar.gz

      - name: Create a vane-cvp distribution directory based on the version being built
        env:
          PUB_BRANCH: ${{ contains(fromJSON('["main", "develop"]'), github.ref) }}
        run: |
          version_str=$(grep ^version pyproject.toml | awk -F " " '{print $NF}' | tr -d '"')
          if ${PUB_BRANCH} == true; then
            tag=""
          else
            tag="-provisional"
          fi
          distro_dir="vane-cvp-${version_str}${tag}"
          mkdir ${distro_dir}
          #
          # Put the distro_dir in the environment
          #
          echo "DISTRO_DIR=${distro_dir}" >> $GITHUB_ENV
          # XXX
          ls -la

      - name: Copy the installation scripts and the rpm into the distribution directory
        run: |
          cp resources/vane-cvp-*.sh ${DISTRO_DIR}/
          cp rpms/*.rpm ${DISTRO_DIR}/

      - name: Archive the distribution directory
        run: |
          tar czvf ${DISTRO_DIR}.tgz ${DISTRO_DIR}

      - name: Save the tarball to the RPM branch
        run: |
          ls -la
          pwd
          # git status || true
          git config --local user.name actions-user
          git config --local user.email "actions@github.com"
          #
          # List the files in the repo
          #
          ls -la
          #
          # Show the current repo status
          #
          # git status
          #
          # Remove all the files in the repo except the .git folder,
          # the README file, and the coverage file. 'or' the command
          # to true since it will fail when trying to delete '.' and '..'
          #
          shopt -s dotglob extglob
          rm -rf !(.git|${DISTRO_DIR}.tgz) || true
          #
          if [ $(git ls-files --others | grep ${DISTRO_DIR}) ] ; then
            echo "Uploading new RPM package"
            # XXX
            # # Copy the version of README from the coverage-badge branch
            # curl https://raw.githubusercontent.com/aristanetworks/vane/coverage-badge/README.md -o README.md
            # Add and commit all the changes we just made, so we end up committing
            # just the README and the coverage badge to the coverage-badge branch
            git add --all
            git status
            # Make the commit, but it will not be saved in GitHub on the working branch
            git commit -am "Uploading new RPM package"
            # Push the commit to the rpm-packages branch (not to the working branch or develop)
            git push -f origin ${{ github.ref }}:gar-rpm-packages
          fi
